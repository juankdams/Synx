0.0.01
- Lecture des configs avec StAX terminée
- Thread de commandes console DOS 
- Constants, CWorlds, CServers, CPersos, ...
- Connexion 100%
- JDBC marche
- Modification de plusieurs packets dans SM.Accounts
- LServer 100%
- Gestion des multiples GServers 100%
- Multi-serveurs disponible
- Note: hibernate = merde pour emu dofus. mieux jdbc
- Insertion d'une map avec Colt dans le LWord pour stock les LAccounts {Note: colt = marde :P}
- G�n�rateur de nom al�atoire fonctionnel
- Cr�ation de personnage fonctionnelle
- Ajout des cadeaux, manque l'intégration des items
- Delete de GPersoCreation et GPersoSelection Handlers, merged dans GHandler qui se charge de tout ce qui est avant le IG.
- Delete des utilisations de screenIDs, inutile et créé des bugs
- Ajout de "maxCoPerServer" dans GConfig
- Début du combo Pools-Timer-Factory dans le package Threads


0.0.02
- Ajouté les methodes SQL.Gift.delete et SQL.Account.updateGift
- Ajouté le cot  sql des amis/ennemies/ignored
- Ajouté des variables dans le LItemTemplate
- Commencé la fonction GPersonnage.onSelected. 
- Mit les GConfigs en objets au lieu de static, une par GServer
- COMMENCÉ tous les parsers (GGameHandler)
- COMMENCÉ la structure des maps
- COMMENCÉ les plugins: chat et console. 
- Ajouté classe Infos, chat, Messages, Basics, Game dans le SM
- Commandes console et joueurs fonctionnelles. (en plugins)
- Ajouté la possibilit  de enlever/ajouter une GConfig+GServer sans reboot
- COMMENCÉ mettre en place la termination/finalization des objects GServer, GWorld, CWorld, GConfig quand on off un gServ
- COMMENCÉ mettre en place c'qui spasse quand on off.
- REFONTE du systeme de GConfig en cours pour des off/on, ajout/delete plus fluides, simple et tout, là c'est chien, compliqué, blabla.
- MISE EN PLACE de JDOM   la place de STaX pour les configs


0.0.03 [7Dec12]
- Mis en commentaire ce qui avait rapport aux siteclient et affaires du genre...tellement plein de marde ces affaires la
   J'veux développer un  mulateur, pas des noobs
   Fack j'leur mettrai un formulaire de config   remplir lors de leur achat. et mettrai en place   la main, plus simple.
     Ensuite ils pourront encore modifier les champs config soit par commande pour le xml soit par bdd et "load sqlgconfig"
- 
- Dans LWorld.isAccountConnected(): ajouté un for pour vérifier aussi dans les comptes qui sont en attentes de connexion 	(la queue)
- Delete GConfig de stax, renommé gconfigJDOM pour gconfig


0.0.04 [8Dec12]
- Ajout  un systeme pour cr er de bdd/tables automatiquement si elles sont manquantes (dans SQL.startUp)
- R organis  les dossiers Syn -> Syn_config, Syn_data ...
- Commenc  les paliers d'xp
- Commenc  la config par bdd (Faudra faire la classe SQL.Config)
- Les clean de L/GClient, LAccount/Gperso quand on d co sont bon
- Ajout  packet de chat pour avoir les canals ouverts   la derniere connexion (pour dans perso.onSelected)
- Ajout  un if(map!=null) dans le packet GDM, faudra ajout  du logging l  dessus
- Ajout  des constantes dans CPerso
- Ajout  la classe CJobs mais sera ptete   delete,   voir avec l'API qui conviendra le mieux pour plus de customization
- Corrig  un bug au choix du serveur quand l'ID a plusieurs digits (>9, comme 22 pour h roique) change charAt->substring
 

0.0.05[9Dec12]
- Continu  la methode pour load les configs bdd.
- Refait la structure de la table de config
- Dans l'initGPerso dans la cr ation de perso, corrig  pour mettre le bon startLvl en fonction de la classeID
- FIXME dans cr ation de perso: si on start   un certain niveau, mettre la bonne xp au d part


0.0.06[10Dec12]
- Ajout  champs maxPersoPerAccount dans gconfig global (static)
- Ajout  le loading des configs bdd dans SQL.setUpConnexion
- Corrig  un bug dans la table config -> ajout  la valeur '' au champs ValueBool pour pouvoir mettre des valeurs null.
- Ajout  une v rification de la validit  des couleurs dans le packet AA de cr ation de perso.
- Ajout  un GWorld.addPerso(p) dans Perso.onSelected
- AJout  un GWorld.removePerso(acc.curPerso) dans GClient.kick
- COmmenc  une methode p.terminate pour enlever toute les r f rences   ses variables et les setter   null
- Cr ation ET Supprimation de perso completement parfaits sur tous les serveurs 
- Ajouté les RATES dans la config bdd + dans GConfig


0.0.07 [11Dec12]
- Ajouté commandes GETMEM, GC, RELOADPLUG, dans la ConsolePlugin
- Modifi� la classe Plugin dans la PluginLib: Ajouté methode abstraites "registerEvents" et "unRegisterEvents"
- Ajouté le chargement des paliers d'xp
- Ajouté newPerso.setChannels et setXP dans la cr�ation de perso.
- Passé le projet en UTF-8 et recopié toutes les classes pour ravoir mes accents ><
- Ajouté un packet AS dans Externals pour de la doc sur le client (Loader+core+lang, etc)
 

0.0.08 [12Dec12]
- Recommencé le système de queue, c'est encore à voir s�rieux, j'ai pas pass� assez de temps l�-dessus ^^
- Créé une nouvelle classe ScheduledTasks, j'sais pas exactement comment je le ferai/ce que j'utiliserai, mais je sais qu'il me faut quelque chose dans le genre pour, par exemple, vider la queue des comptes qui ne se sont finalement jamais connect�s; envoyer les packets pour l'affichage des d�placements/lancement des sorts en combat au bon moment.
- Commencé un systeme de proxy pour permettre de faire des reboots sans perdre les connexions. J'suis pas encore s�r pour ce projet...j'ai de doutes quant aux performances. Googleismyfriend
- Un peu leech sur le serveur officiel espanol de fait pour v�rifier que tout soit parfait jusqu'� maintenant ^^
- Créé classe GameParser et boug� les methodes onGameCreate et on GameInfo dedans. Faudra faire un plugin pour ca pour pouvoir faire des modification en tout temps sans reboot
- Corrigé le packet AxK pour afficher la liste des serveurs
- Ajouté variable lastConnexionDate dans LAccount + fait les modifications nécéssaire dans onSelected
- Continu� le onSelected, ajouté pas mal de packets là dedans et dans le SM (ZS, fC, ImBienvenue)
- TODO: Corriger packets AXK/AYK, l'offi utilise le AXK 
- TODO: Continuer la method perso.parseItemsToASK [FINIT]
-      Continuer les items et les inventory
-      continuer les Items.loadInventoryXXX [FINIT]


0.0.09 [13Dec12]
- Continué les items
- Continué les inventaires
- Ajouté des methodes dans GWorld pour remove des items et inventory
- TODO : SQL.Perso.save avec la colonne d'items(faut modif la table) (jai commenc�)
- Ajouté un GWorld.add new GInventory() dans la cr�ation d'perso
- Ajouté un constructeur GInventory(startItems[][]) qui se remplit automatiquement avec les startItems, cr�� ces items, les met dans le world, et s'ajoute luimeme au world.
- Ajouté champs startItems dans G/SConfig avec possibilité de mettre une quantité à chaque item.
- Ajouté méthode de finalization (terminate) dans GInventory et ajouté un call à celle-ci dans GPerso.terminate()
- Ajouté int lastItemID dans GWorld + methode getNextItemID
- Mit les methodes de getNextPerso/ItemID en synchronized pour �viter d'avoir deux persos/items avec le meme ID
- Modifié Items.loadInventoryComplete pour que si world.getInventory est null, on cr�� un nouveau inventory vide pret à recevoir les GItems du perso.
- Ajouté method getItemsString dans GInventory
- Finit methode GPerso.parseItemToASK et réorganisé SM.Account.ASK
- Finit methode GPerso.parseAccessories
- Modifié le Gclient.kick pour terminater TOUS les personnages du compte du lieu de juste le current
- Ajouté toutes les maps d'ancestra dans la table de map du login
- Ajouté des newPerso.setMap/Cell/Kamas dans GHandler.createPerso() pour 
- Ajouté SQL.Items.loadLastItemID() dans le construct GWorld
- Ajouté SQL.Items.create() quand on créé les items dans le construct GInventory à la cr�ation du perso
- FIXME: Y'a encore un probleme sur les ginventory, en se connectant 
	et ensuite changer de perso/serveur, donc en déconnectant le GClient,
	la method p.terminate a tjrs un nullpoint sur linventaire comme sil existait pas 

0.0.10 [16Dec12]
- Ajout d'une enum Lang + class LangConfig + i18n.xml = Un petit i18n qui marche en fonction du language de la communauté du monde du serveur. Ex: OtoMustam = anglais. Jiva = francais.
- Ajout du chargement de l'i18n au chargement de l'emu.
- Modifié l'enum GMCommand: Ajouté une valeur GMlvl
- Modifié le ConsoleListener, ajouté la détection et l'envoi d'un message si la commande n'existe pas ou que le GMlvl est trop bas (lvl v�rifi� gr�ce à la modif dans l'enum GMCommand)
- Ajout des premiers usages de l'i18n dans la plugin de commandes console.
- Corrigé le bug de nullpointer avec les GInventory. 
- Vérification sur JProfile: Tout se finalize bien, toute les variables qqui ne devraient plus exister s'en vont. (Gclient, GPerso, LAccount, GItem, GInventory...)
- Prochains codes que je ferai ca sera pour le scheduling de packets et d'actions.


0.0.11 [17Dec12]
- Ajout� des nouveaux loggers dans les classes qui en avaient besoin et qui utilisaient celui de Syn.log à place du leur.
- Avanc� le scheduling de packets/tasks et les buffers de schedule. (Voir Scheduling et SchedulingBuffer)
- Ajout� une classe Exceptions pour thrower les exceptions dont j'pourrais avoir besoin
- Ajout� un dossier Syn_logs avec un Exceptions.xml avec les exceptions les plus fréquentes que j'verrai.
- Ajout d'un writer pour logger les exceptions lancer dans ma classe Exceptions.java
- Dans le package SQL: Enlevé les "extends SQL" pour mettre des import static SQL.SQL.xxx; à la place.
- Pareil dans le SM: remplacé les "extends Sender" par : import static SM.Sender.send;
- Beaucoup avancé le Scheduling et SchedulingBuffer: utilisation des UtilityThread pour ticker les buffers. Restart du UT chaque fois (par exemple) qu'on ajoute un compte � la Queue. Pause du UT � chaque fois qu'on le tick (pcq la list est clear�e � la fin du tick donc rien � faire). R�activation du bigTimer dans Syn, des UtilityThread et des Pools. Ajout du type SCHEDULED_BUFFER dans UT.
- Queue fonctionnelle avec les nouvelle ScheduledTask qui s'ajoute aux buffer (SchedulingBuffer.getBuffer(1000).modifyBuffer(ADD, new Schedule(date, objet, action)))
- Scheduling fonctionnel. Exemple avec commande SCHEDULEDPACKET [message]: Va envoyer un packet (le message) � la personne une seconde apres la commande. Tous les objets utilis�s se terminent/finalize bien.
- Ajouté le champs SPECIFY_PARAMETER dans l'i18n  

0.0.12 [18Dec12]
- Avancé le chat, ça marche bien.
- Ajout de listes des persos ayant floodé dans les canaux commerce/recrutement/global...
- Ajout d'une schedule pour enlever les persos floodeurs des listes apres 1 seconde pour general et 1 minute pour commerce/recrutement.. 
	Ainsi le perso peut pas envoyer de message (ex) en commerce à l'intérieur d'une minute d'intervalle
- Ajouté un utilityTh pour Régénérer la Vie des persos en permanence (+packet ILF,ILS)
  	Encore à travailler + faudra surement plusieurs UT pour s'occuper de ca pour de la scabilité
	Pis faut aussi ajouter la précision que si le personnage est assis il regagne plus vite sa vie.
- Ajouté des enums pour les actions de Syn(Comme pour les UtilityThread/Scheduling...)
- Ajouté enum "ChannelEnum" pour les channel. Modifié le ChatParser pour y correspondre.
- Ajouté enum "EmoteEnum" pour les emoticons comme /sit, /rest, /pipo, etc  
- Ajouté enum "SmileyEnum" pour les smileys comme :) ou :( ou :'( ou XD
- Ajouté la classe SM.emotes
- Corrigé le packet SM.emotes.eU
- Commencé à ajouter les emotes dans le GGHandler
- Le bug du canal information en chat persiste...bizarre...
- Rename l'interface DofusMap -> IMap
- Ajouté interface ICharacteristics dans src.Interfaces. C'est un début xd, 
	faut trouver une manière implémenter ca pour les perso/mob/item/pnj...


0.0.13 [19Dec12]
- Ajouté le fonctionnement des smileys
- Ajouté une vérification que le message recu par les L/GHandler est bien une string.
- Bougé la method parseItemToASK de GPerso à dans SM.Supplements
- Modifié les buffers de flooders dans le ChatParser: mis en objet 
	Modifié la method modifyFloodLists pour prendre compte du GWorld et accéder aux buffers
    Ajouté un objet ChatParser dans GWorld 
- Créé un TitleManager qui contient tous les id de perso ayant un titre et l'id du titre
   	Ajouté un objet TitleManager dans GWorld 
- Fait le GameParser.onGameInfos();
- Ajouté classes: GPrism, GMonster, GTaxCollector, GNpc
- Créé interface Character implémentée par GPerso, GNpc, GMonster, GPrism, GDrago, GTaxCollector, 
- Ajouté getSize, getGMpacket, 
- New Enum CharacterType
- Implémenté la method getGMPacket() ds les GPerso
- Ajouté method SM.Game.GM_ADD_ALL et GM_ADD
- Modifié l'arraylist de perso pour une al de characters dans Map
- Modifié ++ classes qui utilisaient le map.getPersos pour mettre map.getCharacters
- Corrigé des références dans ConsolePlug à SchedulingBufferA qui est renommé CommonAction
- Ajouté champs config pour le niveau de l'aura 100 et 200 et le niveau max.
- Corrigé l'activation/désactivation du canal bleu qui controle les channels TEAM, PARTY et PRIVATE
- Ajouté Interface ICharacteristics. 
- Ajouté Class GStatistiques, BaseStatistiques, FightStatistiques, EquipmentStatistiques, GiftStatistiques
- Commencé les statistiques/charactéristiques/effets + packet As
  	Note: Si on le fait avec JEP, ca va prendre bcp de ram. [FAUX] ca prend genre 4Mb O.o
  	Si on le fait avec une seule classe de charactéristique avec 50 int, 
  		ca fait 200 int par perso donc 800bytes par persos. Donc 4Mb pour 5000 persos. CA TORCHE
- New Enums: Characteristic/EffectType 
- Ajouté method dans GWorld: getFight et getFightByCharacter
- Ajouté var ID dans GFight et method isCharacterInFight et ArrayLists fightersBlue/Red


0.0.14 [20Dec12]
- Ajouté une table pour les titres
- Ajouté un int[] dans TitleManager pour stocker les titres chargés
- Ajout d'une classe sql Others pour tout & n'importe quoi.
- Ajout du chargement des titres à la création du monde
- Delete la class sql Xp, mit le loading des paliers d'xp dans la classe Others
- Delete les actions de Queue qui étaient en static final int, utilisation de CommonAction à la place
- Modifié l'arraylist characters dans Map pour quelle soit nulle chaque fois que la map est vide. so moins de ram
- Delete method getFightCount dans Map
- Enlevé la save sql des channels chq fois quils étaient updatés
- Ajouté un sql.perso.save(this) dans gperso.terminate
- fait de la recherche sur les caches, intéréssant..surement bon pour stocker des map offi, item,montres
- Finalement trouvé et commencé la meilleure manière de coder 
	le stockage des charactéristiques.
- Changé les GConfig.startMaps de int en short et ajouter un peu de sécurité
- commencé le packet SM.Account.As


0.0.15 [21Dec12]
- Refait l'enum CharacteristicType + mit tous leurs VRAI ID (pas les ID des effets)
- finit le packet As
- TODO: mettre les capital/spellpoint et cie dans l'hashmap au lieu de tous seuls, 
	ils ont bien des ID dans CharacteristicType donc..
- TODO: Faire la save/load des characteristiques de base.
- Commencé la vrai enum des Effets. 
- Ajouté une table pour les charactéristiques de base, 
	KEEPEYE à voir pour la performance s'il faut vraiment que j'la merge dans la table de persos
- Ajout de la création de nouvelles statistiques à la création du perso.
- Agout de la création des statistiques dans la bdd
- Ajout du chargement des statistiques de la bdd
- 


0.0.16 [26 Décembre]
- FIXME Modifié le GHandler.deletePerso, c'pas fini pis jai codé plein dmarde 
- FIXME faut corriger la gérance des statistiques à la création et chargement
- FIXME plein dmerde
- Remodelé le GHandler.createPerso et deletePerso
- Ajouté method GPerso.createNew
- Ajouté method GStats.createNew
- Ajouté method GStats.terminate
- Ajouté method sqlPerso.deleteCharac
- Modif method sqlPerso.createCharac (mit des setByte pour les PA/PM)
- Ajouté method sqlPerso.saveCharac
- Modifié le Perso.terminate, ajouté la save+termination de charac
- Déplacé le call à sqlPerso.createCharac pour mettre dans GHandler.createPerso à coté du SqlPerso.create()
- Corrigé finalement les stats grâce à des casts, 
	faudra quand même vérifier leur relations autours 
	avec les create/save/load/terminate/delete, etc
- Mit l'energy/statspoints/spellpoints  dans la map<> stats au lieu d'un short à part
	et modifié les setEnergy, setStatsPoints, setSpellPoints et delete leur get(), 
	y'a déjà le getValue() so..;p
- Corrigé l'affichage de l'XP dans packet As
- 	... ca va assez bien, cest mieux qu'avant en tout cas :)

0.0.17 [27 Décembre 12]
- Mit les Queue en objet à chaque GServer
- Modifié la ScheduleTask pour enlever un compte d'une Queue (Ajouté le parametre obj[1] GServer)
- Modifié tous les rapports à Queue.updateQueueAccounts
- Modifié LWorld.isAccountInQueue pour vérifier dans toutes les queues objets
- Corrigé bug chat, c'tais à cause du message de bienvenue dans le config qui était mal écrit, il manquait un ' dedans. 
- Ajouté les Orientations

0.0.18 [30 Décembre 12]
- Ajouté le parsing des Orientations au complet.
- Ajouté que si le perso est assit et demande une orientation non-diagonale (c'qui ferait bug le sprite), on renvoie l'orientation suivant la demandée
- Bougé la constante channels dans CPerso au lieu de Constants
- Ajouté une byte[] pour contenir les ID d'emotes apprises par le perso
- TODO : mettre une colonne emotes dans table perso pour les save
- Ajouté method addEmote et removeEmote dans perso
- Ajouté addByteToArray et removeByteFromArray dans Utils
- Ajouté addElementToArray et removeElementFromArray dans Utils
- Ajouté que si on est assit et qu'on fait l'emote asseoir, le perso se leve debout
- Ajouté une verif de si le destinataire est en combat quand on envoie le packet eD (changeDirection) aux persos de la map.
- Changé les types des valeurs des EmoteEnums de int à byte.
- Ajouté packet BD (thx BlackRush)
- Corrigé un throwException dans les Exceptions. le NumberFormat lancait un nullPointer xd
- TODO bug de lib avec jodaTime pour le packet BD (packet pour indiquer la date)
- TODO finir les effets des emotes (gagner vie en mangeant pain, faire bouger une drago, etc)


0.0.19 [31 Décembre 12]
- Corrigé/finit systeme de régénération automatique + en étant assi/couché avec pascket As etc. 
	Packet As prend 0ms 
	Donc fini la classe LifeRegenerator et le bout dans Factory.UtilityThread.REGEN
- Mit les pdvMax correctement au chargement des stats dans SqlPerso.loadStats et dans Stats.createNew(); 
	C'est pour avoir la bonne vie de base en fonction du level (+5pdv par niveau)
- Ajouté commande SETPDV dans GM4 dans le consolePlugin.
- Changé la grosseur de base du StringBuilder du packet As de 500 à 400
- Ajouté ptite classe Perfs dans les Utils
- Modifié le temps entre chaque tick du tiemr de regen. 1000 au lieu de 2000ms
-

0.0.20 [1 Janvier 13]
- Commencé à faire les packets de Queue comme il faut
- Ajouté packet Aq
- Checké les ref au packet SM.Account.Af
- Ajouté un objet Queue dans le LoginServer
- TODO faudra surement mettre le packet Aq pour la queue du loginServer [Fait][Mais non, mit un Af, comme offi]
	et garder les Af pour les queue de gameServers
- TODO faudra surement aussi envoyer le packet Af direct au choix du serveur [Fait]
	quand on recoit AX (dans LServerSelectionHandler)
- TODO: En faite ca serait nice de faire une vraie de vraie queue 
	dans laquelle on fait l'action (ParEx.)	de parser le packet GM un à un.
	En ajoutant ceux qui se connectent à la fin de la queue
	Et en les parsant un à un et enlevant le premier de la liste, celui quon vient de faire.
	Et renvoyer le packet Af à chaque..3secondes metons :P
- Bon sinon les packets de queu (Af) sont les bons et fonctionnent bien. 
	Y'a juste les int numberOfPremium dans le LServer qui sont à surveiller
	Genre si qqn s'connecte, ca augmente le chiffre, et fait qqc et le chiffre redescend pas...
- Ajouté packets BAT0, BAT1 et BAT2 dans SM.Basics (BAT_NEUTRAL,FAIL,SUCCESS)
	- Faudra changer les SM.Messages.MC pour ces packets là et bien utiliser les fails/success/info
- BUG: À la connection, l'ancien nbr de pdv (à la derniere déconnexion) devient le pdvMax [Corrigé]
	et c'est ce chiffre (devenu pdvmax) qui est savé dans la bdd à la place de l'ancien 		
	Fack on a toujours 100% pdv en se reconnectant même si avant on avait 8% ou whatever
- Remit la grosseur de base du StringBuilder du packet As de 400 à 500


0.0.21 [2 Janvier 13]
- Corrigé le bug des pdv qui arrivait en déconnectant/reconnectant.
- Testé la vitesse de String.format VS new StrinbBuilder.append(); 
	Le StringBuilder est presque 20 fois plus vite..(Sur mon vieux portable) 
	Ajouté la methode de tests dans Misc.Tests
- Ajouté addIntToArray/removeIntFromArray adns Utils
- Ajouté methodes add/remove Friend/Ennemy/Ignored dans LAccount
- Minibug: si tu set le lvl à metons 47 via la bdd quand t'étais lvl 1, 
	ben en te connectant, l'xp reste à 0 mais sur 4 400 000.. x)
	ca sera juste simplement gérer dans une commande SETLVL ou whatever genre perso.incrementXP
- Ajouté classe Formulas
- Ajouté method calculateInitiative dans Formulas (Manque juste d'additionner le bonus d'alignement la dedans)
	+ ajouté constante CPerso.gainedInitByIntelAndAgiPoints
- FIXME Ajouté methode calculatePods dans Formulas [TODO: manque calcul avec les métiers] (http://forums.jeuxonline.info/showthread.php?t=801243#Le nombre de Pods)
	+ Ajouté constante CPerso.statPods
- Ajouté methode calculateProspection dans Formulas
	+ ajouté constante CPerso.gaindProspecByChancePoints
- Modifié le packet SM.Account.As: ajouté la valeur du calcul de l'initiative et de la prospec.
- Modifié la methode GStats.getPacket, enlevé le getValue(INIT, BASE) et prospec au début de la méthode 
	vu que mtn ils sont directs dans le SM.Account.As
- Ajouté le boost de characteristiques dans GGameHandler (RECV Packet AB) 
	+ Ajouté constante CPerso.characPointsByBoost
	L'initiative est bien calculée et affichée chaque fois qu'on boost une charac
	Le nombre max de pods aussi en boostant la force
	Et la prospec aussi en boostant la chance.
	Faudra surement un AccountParser, ce switch là risque d'être gros.
- Créé class SM.Objects
- Ajouté methode Ow dans SM.Objects pour afficher les usedPods sur les maxPods quand on ouvre l'inventaire.
- Renommé LItemTemplate en ItemTemplate
- Ajouté une ArrayList d'itemTemplates dans le GWorld
- Ajouté méthodes getItemTemplate et addItemTemplate dans GWorld
- Créé class GlobalWorld dans GlobalObjects
- Ajouté methode getItemTemplate dans GlobalWorld 
- Changé l'int templateID dans GItem pour un ItemTemplate "template"
- Renommé toutes les methodes référant à l'ancien templateID en getTemplate, etc
- Ajouté methode getPods dans GItem
- Ajouté methode getPods setPods dans ItemTemplate
- Ajouté variable pods dans l'array "params" dans ItemTemplate
- Ajouté methode getUsedPods dans GIenventory pour savoir le poids total utilisé 
	par tous les items de l'inventaire
- Dans la methode SM.Objects.Ow: mit le packet "Ow"+inventory.getUsedPods+'|'+Formulas.calculatePods
- TODO: Faire la table ItemTemplates dans les bdd login ET worlds  [FAIT]
	(la même structure) (+Mettre tous les items officiels dans celle du login)
	À faire en fonction de la methode SQL.Items.loadTemplate que j'ai commencée
- TODO: Finir méthode GInventory.getBonusPods pour avoir le total de bonus de pods sur les items équipés  [FAIT]
	pour calculer le nombre de pods max du perso. 
- TODO: Finir la méthode Formulas.calculteMaxPods utilisant le inventory.getBonusPods (Manque ca et les bonus par les métiers)	
- TODO: Finir l'enum des Effects	[FAIT]
- Ajouté methode getMap dans GlobalWorld pour pogner une map dans gworld, Gbdd, LWorld ou Lbdd
- Changé la methode perso.getMap pour mettre GlobalWorld.getMap dedans
- Ajouté ref à SM.Objects.Ow dans perso.onSelected et dans le boost de stats dans GGameHandler.parseAccounts (RECV Packet "AB")
	Ca fonctionne bien: l'affichage est parfait et quand on boost la force, le maxPods monte.
- TODO: Faire la vérification d'avoir le bon nombre de capital pour booster une charac   [FAIT]
	et retirer ce nombre apres l'avoir booster


0.0.22 [4 Janvier 13]
- Ajouté GMCommand GETCOMMANDS(10)
- Changé tous les SM.Messages.MC dans le ConsoleListener pour des SM.Basics.BAT_XXX
- Ajouté les constantes minimumIDinWorldItemTemplateTable et pour les maps dans CServers. Les deux à 15000
	et modifié GlobalWorld.getXXX() 
	Il ne sera donc plus possible d'overrider un objet du login dans un world, seulement de l'utiliser.
- Fini les constantes d'index pour les parametres dans les arrays 
- Installé ces constantes dans GPersonnages à chaque fois qu'on utilisait un call aux arrays[]
- Ajouté des constantes pour des Im messages dans Constants 
	et les ai utilisé dans GPersonnage.onSelected (Messages de bienvenue) 
- Mit le MapID de GPersonnage et ICharacter en int plutôt qu'en short 
	mais à vrai dire, il faudrait le mettre en short 
	et interdire aux créateurs d'utiliser des ID > 32000 et < 15000
	Pareillement pour les ItemTemplate ID
- Ajouté method parseObjects dans GGameHandler (avec le sender du client en comments) 
	et le parser du client en commentaires dans SM.Objects	
- Commencé la table ItemTemplate	
- Testé Syn sur le dédié: apparemment les GameServers et ptete meme le Login se OFF pas quand on éteind l'emu :> Y'aura des process à tuer (kill) par le WHM
- Commencé le Syn.closeAll et le LServer.off(); TRÈS ÉTRANGE QUILS NAI PAS ÉTÉ FAIT.


0.0.23 [5 Janvier 12]
- Étant donné que j'ai remarqué que le Syn.closeAll était pas fait et que le LServer.off non plus, 
		j'ai du faire beaucoup de travail par rapport à ca :
- Ajouté le .off() dans LServer
- Ajouté saveAll dans LWorld
- Ajouté .save dans SQL.Accounts
- Modifié .load dans SQL.Accounts
- Delete l'array de banques dans LAccount
- Mis une string contenant les serverID des banques du perso dans LAccount (à la place de l'array)
- Changé LBank pour GBank
- Enlevé la table banks de la bdd du login
- Mis la table banks dans les bdd des worlds
- Modifié la table banks: changé colonne id pour accountID, ajouté kamas et ajouté items.
- Mit la table banks nécéssaire aux worlds dans SQL.BDDWorldTemplate et enlevé de SQL.BDDLoginTemplate
- Delete la variable ID dans GBank
- Corrigé methodes GBank.delete et .terminate
- Complété methodes addItem, removeItem, getItems, getItemById, emptyItems, deleteItem dans GBank
- Ajouté variable long kamas dans GBank
- Ajouté methode setKamas et getKamas dans GBank
- Ajouté method getItemsString dans GBank
- Créé une HashMap de <accountID,GBank> dans GWorld
- Ajouté method getBanks, setBanks, getBank(accountID), addBank(accountID,bank), removeBank(accountID)
- Ajouté static String load/create/save/deleteBankQuery dans SQL.Banks
- Ajouté methode create, saveBank, delete et load dans SQL.Banks
- Ajouté la création de banque quand un compte se créé un new perso dans un nouveau world
- Ajouté le delete de banque quand le compte delete son dernier perso dans un world
- Ajouté le chargement de la banque du world du compte à la sélection du personnage
- Ajouté la termination de la banque quand le perso se déconnecte
- Ajouté la sauvegarde de la banque quand le perso déconnecte
- Ajouté la sauvegarde des items de la banque quand il se déco.
- Ajouté la sauvegarde du compte quand il se déconnecte
- Créé interface IStorage
- Ajouté method getItems(), getItemByID(id), removeItem(item), addItem(item) dans IStorage
- Implémenté IStorage dans GInventory et GBank
- J'ai pas testé, mais les banques devraient maintenant super bien marcher
- TODO: Finir LWorld.saveAll et .terminate  la meme maniere que dans GWorld


0.0.24 [6 Janvier 13]
- Enlevé la partie  && c.equals(newC) == false){ dans SM.Game.GM_ADD et GM_MODIFY
	 pour envoyer le packet au personnage ajouté à la map aussi au lieu de juste aux autres de la map
- Y'a un bug de nullPointer sur les GStatistiques dans :
	Exception in thread "UT" java.lang.NullPointerException
	at Threads.Factory$UtilityThread.executeAbstractTask(Factory.java:170)
- Ajouté commandes SETCELL et SETMAP et SETSIZE
- Bug à la sauvegarde d'account (commande save pour saveAll les GWorld+LWorld) dans SQL.Accounts.save
- Bug commande EXIT, marche pas
- Bug de concurrence dans:
	Exception in thread "UT" java.util.ConcurrentModificationException
	at java.util.AbstractList$Itr.checkForComodification(Unknown Source)
	at java.util.AbstractList$Itr.next(Unknown Source)
	at SM.SchedulingBuffer.executeSchedules(SchedulingBuffer.java:91)
	at Threads.Factory$UtilityThread.executeAbstractTask(Factory.java:176)
	at Threads.ModalT.executeTask(ModalT.java:51)
	at Threads.ModalT.run(ModalT.java:68)
	at java.lang.Thread.run(Unknown Source)
- Ajouté commande SETGM(9)	
- Testé l'affichage des items dans l'inventaire 
	(testé avec Packet SM.Account.ASK, mais c'pas le bon à utiliser. ASK cest à la connexion seulement)
	marche bien, suffit que le template soit pas null.


0.0.25 [8 Janvier 13]
- Corrigé le bug de sauvegarde de comptes dans SQ:.Accounts.save (C'tait dans l'écriture du query, il manquait un ' avant friends)
- Ajouté un synchronized(list)
- Ajouté constantes SchedulingBuffer.tick1second et tick1minute
- Ajouté method stop() dans Threads.Timer 
- Ajouté ref à globalTimer.stop() dans Syn.closeAll
- XXX : quand on se connecte, ca fait 6 appels d'un coup à:     (Donc cest lourd en temps CPU vu que c'est synchronized)
	 [DEBUG]: Queue.updateQueuedAccounts - GETVALUES 
- TODO: Faire methods GWorld.saveAll, cleanAll et rebuildAll 
- TODO Corriger les bugs quand on fait commande EXIT (D'la concurrance, des nullpointers, plein daffaire)
- TODO: Finir l'enum EffectType, finir la method GInventory,getBonusTotalPod, finir table itemTemplates [FAIT]
- Modifié l'array de parametres dans ItemTemplate
- Ajouté des constantes pour les index de l'array de parametres d'itemTemplat dans Constants.CItems
- Ajouté des méthods dans ItemTemplate: get/set BonusCC/EC, isEquipment/Weapon/SellingItem, 
- Faudra trouver une place pour mettre le price dans ItemTemplate 
	car on peut pas le mettre dans l'array de param short, c'trop petit comme chiffre 32000
- Mit une Interface IItemTemplate
- Modifié la class ItemTemplate en ItemTemplates avec plusieurs sous-classes
- Créé class WeaponItemTemplate et SellingItemTemplate
- Continué le SQL.Items.loadTemplate: ajouté des conditions de min/max sur les valeurs et ajouté des constructeurs, etc
- Remplacé toutes les références à ItemTemplate par IItemTemplate (l'interface)
- Modifié LWorld.getItemTemplate pour avoir un controle du min/max des ID d'item et ajouté le loading d'itemT la bdd
- Remit le chargement dynamique d'SQL.Items.loadTemplate() dans GWorld.getItemTemplate
- Finit la méthode SQL.Items.loadTemplate()
- Finit la table itemTemplate
- Ajouté methode transferItemTemplateFromZenToSyn dans SQL.Items
- Transféré tous les itemtemplate d'ancestra/zen à Syn
- Packet BD et son bug de lib corrigé
- TODO: GInventory.checkAllEquipedItemsConditions [FAIT]
- AJouté method getCanStack dans GInventory
- Créé class ObjectsParser
- Ajouté method parseOnMovement, parseOnDrop, parseOnDelete dans ObjectsParser
- Ajouté method incrment/decrementQuantity dans GItem
- Rename l'enum ItemCondition en Condition car elles peuvent s'appliquer à des scriptedcells/triggers/teleport/etc, C'est utile. 
- Corrigé la method GWorld.getPersoByName
- Ajouté commande ITEM(5) dans consoleListener/GMCommand
- Bougé SAVE(10) à SAVE(7)
- Ajouté method objectCanBePlacedAtPosition dans CItems
- Ajouté constante BaguetteVelueAPasBesoindeLigneDeVue dans CItems
- Ajouté plein de packets dans SM.Objects
- TODO: Commencé packet OAKO mais il manque les stats des items pour le faire  [FAIT]
- TODO: GItem.getEffectsPacket  [FAIT]
- Ajouté les constantes des position d'item pour les bonbons/personnages suiveurs/envoutements/mutants
- Corrigé les constantes de position d'item des items utilisables (itemBar 1 à 14)
- FIXME: Gérer les bonbons/envoutements/personnages suiveurs aux bons endroits (candyBar 1 à 8)
- Rename EffectType en SpellEffectType, 
- Créé enum ItemEffectType
- Créé interface EffectType implémentée par SpellEffectType et ItemEffectType
- Créé sousnum DamageEffect et HealEffect dans SpellEffectType
- Rempli SpellEffectType, rendu à 670 sur 999
- Créé class GEffect
- Ajouté Arraylist<GEffect> dans GItem
- Créé class Dice
- TODO: Finir de remplir SpellEffectType et ensuite tout séparé entre là et ItemEffectEnum
- Continué de remplir 
- Ajouté method getBoostCostAndCountForCharacteristic dans CPerso (inspirée du client dans Datacenter.LocalPlayer.getBoostCostAndCountForCharacteristic)
- Remodelé le recoit du packet AB dans GGameHandler.parseAccounts()
- FIXME: Probleme de pdvMax et de pdv de base quand on boost la vitalite [FAIT]
- TODO: Faire Packet OA pour ajouter des items à l'inventaire  [FAIT]
- TODO: Mettre la variable price dans EquipmentItemTemplate de base	et ajouter la method get/setPrice dans l'interface IItemTemplate
- TODO Refaire le stockage des effets des GItems/ItemTemplates   [FAIT]
- TODO: Dans GEffect, pour faire la génération de stats aléatoires pour les GItems,   [FAIT]
	faut vérifier que le GItem peut être modifié ou s'il doit resté exactement comme le template
	C-a-d, est-ce qu'on pogne un jet aléatoire (EX pour un bonus de force)
		ou bien on y touche pas (Ex un effet de dommages eau sur une arme)
		Donc une liste de ces EffectsIDs
- Ajouté methode getEffect(short id) dans DamagingEffect et HealingEffect (Dans SpellEffectType)
- TODO: Continuer sur la methode isNonVariableEffectOrUnique et le constructeur de GEffect.
- TODO: Corriger la commande ITEM dans le console plugin  [FAIT]
- BUG, desfois les GStatistiques deviennent null. So j'ai mit une requete sql dans le .get() 
	et s'il la trouve pas, le compte est banni
- TODO: Refaire la méthode ObjectsParser.parseOnMovement au complet, faire plus organisé,    
	gérer mieux tous les cas de figures car il m'en manque en ce moment; cest mal fait
	(Et faire les autres methodes ObjectsParser aussi)
- TODO: GInventory.checkAllEquipedItemsConditions	[FAIT]
	
	
0.0.26 [9 Janvier 2013]
- Ajouté method isAccessory() dans GItem	
- Ajouté method hasSameEffectsAs dans GItem pour voir si deux item ont les mêmes effets/stats
- Ajouté une ref à hasSameEffectsAs dans GInventory.getCanStack()
- Ajouté method Dice.getString
- Ajouté method GEffect.getString()
- Fini method GItem.getEffectPacket
- TODO: Enlever le getAccessoriesPacket de GPerso, mettre dans ginventory, SM.Object, qqc chais pas mais pas perso
			Pareil pour le getASK pis getGM (Non ptete pas getGM, c'est interfacé dans ICharacter)
- TODO: finir GInventory.getTotalBonusPods [1ere correction faite, à tester]
- TODO: Finir GEffect.isFixEffectBonus
- Corrigé method getRandomShot dans Dice
- KEEPEYE: Dice.getString: Pour les valeurs négatives :s
- Delete (en comments) l'HashMap contenant tous les GItem dans GWorld, c'tait completement inutile en ce momen en tk
- Ajouté un 
- Ajouté methode createNew dans GInventory et GItem
- Delete un constructor dans GInventory et GItem
- Mit en comments SQL.Items.loadItem(id,world)
- Modifié GItem.createNew: mit un return null au début si le template est null
	+ Modifié GInventory.createNew, 
		plus besoin de faire deux fois GlobalWorld.getItemTemplate pour vérifier s'il est null
		ca va plus vite en vérifiant à l'intérieur de GItem.createNew et en checkant si ca retourne null
- Ajouté constantes de short ZERO,ONE,TWO...jusquà 10 dans Constants.Constants 
	et changé quelques cast (short) pour mettre ca		
	Fait pareil avec les bytes
- Créé sous-enum GMLevel dans la lib Plugins dans ZPlug.ConsoleEvent
- Ajouté des références à GMLevel dans ChatPlugin.ChatListener
- TODO: Delete l'enum ConsoleEvents avec les GM_1, GM_2 etc et met juste l'enum GMLevel
	et change l'event quand on lance une commande, au lieu de mettre le GM dans l'event, met la commande elle meme
	et t'as juste à vérifier le GM avant de lancer la commande
	et enlever le switch(GM), garder seulement le switch(commande) général
- Ajouté method GEffect.createNew()
- Ajouté constructeur GEffect() et GEffect(String stats) 
- Delete (en comments) constructeur GEffect(String stats, bool parfait)
- Ajouté condition dans SM.Infos.ILF ("Vous avez retrouvé X pdv"): 
	on n'envoie pas le packet si le gars a gagné 0 pdv
- Aux références à CPerso.pdvMaxPointsPerLevel, quand on faisait CPerso.startPdv+(pdvMaxPointsPerLevel*lvl-1):
	enlevé le -1 ce qui donne CPerso.startPdv+(pdvMaxPointsPerLevel*lvl-1
	ce qui donne 55 pdv de base (Comme offi quand on créé un perso de nimporte quel classe)
- Ajouté condition +energy et +vie dans GEffect.isFixEffectBonus
- TODO: Continuer d'ajouter des conditions dans GEffect.isFixEffectBonus 	
- Ajouter la fonctionnalité de rechercher un ami dans la liste des serveurs:
	Ajouté parsing du packet AF dans LServerSelectHandler 	
	Ajouté method SM.Account.AF
	Ajouté method SQL.Accounts.findAccountPersoList
	Ajouté le comptage des perso dans chaque serveurs du compte recherché (Dans findAccountPersoList)
	Ajout du packet AF + de l'envoie dans LServerSelectHandler
- Modifié method GEffect.getString() pour les fixEffects (Pour l'affichage IG, 
	sans ca ca faisait (ex)  +1 à 1   ou   +43 à 43, etc).
- Ajouté du controle de vérification de packet dans OP.parseOnMovement: 
	sur la position recue et l'id d'item recu. 
	FAIT PLUS ATTENTION À CE QUE TU RECOIS, TU LAISSE PASSER DES FAILLES
- Créé enum ItemPosition + rempli avec ce qu'il y avait dans CItems
- Modifié l'enum CharacterType: mit en byte au lieu d'en int
- Ajouté constantes ONE_MIN_BYTE jusqu'à dix pour les byte -1,-2,-3 jusqu'à -10  dans Constants.Constants
- Ajouté EffectType DURABILITY
- Ajouté method isEthere dans GItem
- Créé class GDropItem extends Gitem
- Ajouté ArrayList<GDropItem> droppedItems dans GlobalObjects.Map
- Ajouté methods in/decrementBaseBoost dans Dice
- Ajouté method getServer, getServerID et getMap dans l'interface ICharacter
- Créé class PathUtils dans Pathfinding
- Ajouté methods dans PathUtils:
	public static short[] getCellsAround(ICharacter c){
	public static short getCell(Map m, Orientation o, short cell){
- Delete l'arraylist de GDropItem
- Créé interface IObject et ISprite extends IObject
- Modifié l'interface ICharacter, mtn extends ISprite et enlevé les methods qui viennent de ISprite
- Modifié l'ArrayList<ICharacter> characters en ArrayList<ISprite> sprites	
- Rename updateCharacterList en updateSpriteList
- ATTENTION: j'pense qu'il va y'avoir des erreurs de concurrences 
	dans (p.ex) SM.emotes.eU() quand on for(map.getSprites()) vu qu'on accede à la liste à chaque itération
		et qu'elle pourrait se modifier pendant cette itération
		ce qui donnerait des erreurs de concurrences 
		mais jsuis pas sur, ptete que le synchronized sur updateSpritesList suffira à prendre soin de ca
- Ajouté methods onAddedToMap et onRemovedFromMap dans interface ICharacter
	+ implémenté dans toute, 
		le onAdd fait SM.Game.GM_ADD  (+ SM.Game.GM_ADD_ALL si c'est un perso)
		le onRemove fait SM.Game.GM_REMOVE
		ou encore SM.Game.GDO si c'est un GDropItem
- Modifié method Map.updateSpritesList avec les onAdded/onRemoved
- Ajouté commande SENDMULT dans ConsolePlugin pour envoyer plusieurs packets au client d'un coup	
- Modifié method ICharacter.getCharacterType et l'ai mise dans ISprite à la place
	Elle renvoie maintenant un CharacterType
	Et j'lai implémentée dans tous les sprites (Return null si le sprite n'est pas un character)
- Changé plusieurs if(sprite instanof GPersonnage) par if(sprite.getCharacterType == PLAYER)
- Modifié la structure du SM.Game.GM_ADD_ALL et rename en showAllSprites() pour monter TOUS les sprites de la map
- Modifié SM.Game.GM_REMOVE: enlevé la vérification if(map != null) et le Exceptions.throwXXX...
- L'affichage des sprites d'item dropés par terre se fait bien, même en changeant de map/déco,...
- Mit if(sprite != newCharacter) dans SM.Game.GM_ADD 
	pour ne pas envoyer le packet de nouveau sprite au nouveau lui-meme
- TODO: peut-etre enlever la variable contenant le GFXid dans GPersonnage ? 
	et remplacer par classe*10+sexe || getIncarnation.getGfx || getEnvoutement, etc
	sauf que ca enleve la possibilité de se morph en ce qu'on veut à long terme.
	Oh tien on pourrait faire un "envoutement morph" 
			comme quand on devient une abra mutante ou un familier fantome.


0.0.27 [14 au 16 Janvier 2013]
- Updaté le SM.Mounts.Rx: envoie le bon nombre de bonus xp donné à la dd grâce aux charactéristiques du joueur (CharacteristicType 73) 
- Corrigé GItem.createNew et dans construct GItem(String stats): enlevé le Short.parsing hexdecimal
- Ajouté method calculatePdvMax dans Formulas
- Ajouté un perso.getStats.setPdvMax(Formulas.calculatePdvMax) dans le RECV AB et au chargement
- Ajouté method updateEquipmentStats dans GStats
- Ajouté ref à updateEquipmentStats dans perso.onSelect
- Corrigé le probleme des pdvMax et de la vitalite quand on la boost
- TODO: Gérer les valeurs négatives dans les effets sur les items 
	(Comme le ADD_X_CRITICAL_FAIL qui a un opérateur '-')
- Fait l'abonnement en partie :
	changé le long premiumTime en premiumDate pour avoir la date de fin d'abonnement
	et mit les methods get/setpremiumdate et isPremium et getPremiumTime (qui donne le temps restant)
- TODO la condition DON("Pg") est ptete utile pour la colonne "Don" dans les characs avancées ? [NON]
- Trouvé quelques maps de départ d'incarnam et mit dans CPerso (Trouvé dans le lang au champs C.INCARNAM_CLASS_MAP)
- BUG IMPORTANT ca pourrait être un probleme d'index sur le account.getCurPerso()
	desfois quand j'suis sur un perso, j'fais setmap (ca marche, jsuis tlp)
	ensuite j'change de perso pour aller sur un autre, 
	j'rechange de perso pour aller sur le premier
	je suis mtn à la meme map/cell que le deuxieme perso.
- Réglé bug du < 0 dans le calcul de l'initiative
- Ajouté method calculateEsquivePA/PM dans Formulas
- Ajouté constante gainedEsquivePointsBySagessePoints dans CPerso
- Ajouté l'affichage de l'esquive pa/pm dans le packet As dans la method GStats.getEsquiveLines
- TODO: Les conditions des items [FAIT, en manque quelques unes]
- TODO: Finir de lister/trier les effets [FAIT, reste à trier, si c'est vraiment important?]
- Dans GStats.getPacket (Pour le packet As): Changé l'appel à DOM_PERCENT pour DOM_FACTOR
- TODO: Faire la régénération d'énergie quand on est déco:  (http://dofuswiki.wikia.com/wiki/Characteristic)
		On pourrait le faire en mettant une lastConnexionDate sur le personnage 
			(juste en bdd, pas dans la class) et en calculant le temps passé offline/1min/1 energy +1 si en taverne/maison/temple de classe
	Another way is by either logging off 
		or switching to merchant mode while your character is in a tavern/inn or in a house
	Characters regain 1 energy point per minute of disconnection anywhere, 
		and 2 energy points per minute if they disconnected in taverns, class temples, or houses
	Your character will recover energy even if you log back in and play an alternate character. 
	When you log back in as the resting character, 
		a notice in the chat window will tell you how much energy was gained.
- Fini de mettre tous les 3XX effets dans SpellEffectType
- Ajouté constante DOFUS_YEAR pour le packet SM.BAsics.BD
- Ajouté envoie packet "Tu es resté trop longtemps inactif" quand le client est déco quand il est idle
- Changé la manière de faire le packet BD, celle de blackrush était pourrie (prend 124000bytes et la mienne 184)		
- Dans GPerso.getFight/GWorld.getFightByCharacter:  À la place de ce qui est déjà installé,
	 * 		on pourrait faire une HashMap à la place de larraylist et mettre une Entry par personnage:
	 * 		Au début du combat, tous les personnages sont ajoutés dans cette HashMap avec leur ID et la fight 
	 * 			Et ils sont tous retirés à la fin du combat.
	 * 		Donc beaucoup plus simple et autant efficiant coté ram 
	 * 			puisque ca se vide facilement (meme qu'une hashmap se modifie beaucoup mieux)
- Dans GFight.isCharacterInFight, 
	on regarde par rapport à un characterID dans des liste de ICharacter les combattants
	Sauf qu'il pourrait y avoir le même ID pour un personnage que pour un mob, 
	donc il faudrait peut-etre mettre les ID de persos positifs et les autres en négatifs (monstres/pnj..)
	ou bien changer le lastPersoID dans GWorld pour un lastCharacterID confondu.
- Ajouté des noms un peu plus explicites aux UtilityThreads	en fonction de leur tâche
- TODO: Enlever la lib Ansi et les calls à tout ce qui écrit en couleur. (Gain de ram)
- TODO: Refaire le package SQL pour les performances ram et cpu. 
	Juste à regarder le screenYourKit pour voir que c'est de la merde
	(C'est ça qui prend le plus de RAM sur Syn en ce moment même!!!!!)
	 Enums.ItemEffectType prend 10ko alors que SQL.SQL prend 677ko
- TODO: Faire des schéma avec des bulles sur papier des opérations que Syn effectue	pour:
	charger le core, charger le LServer/LWorld, charger les GServer/GWorld,
	fermer un GServer,
	fermer l'emu au complet,
	connecter un compte,  choisir un serveur, choisir un perso, 
	déconnecter un perso, déconnecter un compte,
	charger un itemtemplate, charger une map,
	créer/charger des stats/perso/inventaires/item/geffect/dice/etc,
	bouger un objet dans linventaire,
	booster des stats de base, booster des stats déquipement, régénérer la vie, 
	etc, pour voir tout tout tout tout tout...
- Implémenté IObject par GFight et fait les methods
- Refait le stockage des fights et leur accès. Ils sont maintenant dans une array[] dans la classe Map
- Refait le stockage des itemtemplate et des maps dans GWorld: mtn en HashMap au lieu d'arraylist
- Ajouté method updateFightsLists(MapAction,GFight) dans Map
- Modifié method updateSpritesLists dans Map pour éviter des nullpointerexception déjà à peu pres impossibles, mais bon, c'est mieux comme ca
- Ajouté GET_FIGHTS,ADD_FIGHT,REMOVE_FIGHT dans SynActions.MapAction
 
 [Coté Client 16 Janvier 2013]
- Travaillé sur mon client: Refait mon parseur avec un charAt(0) unique non-utilisé par dofus + un char de plus que sur dofus (3 au lieu de 2)
- Ajouté l'augmenteur de stats que Yann m'a dessiné 
	en overridant le Account.boost pour afficher le panel direct au lieu d'envoyer le packet AB
	+ ajouté packet @BScapitalToUse,characID à envoyer
	+ ajouté packet @BSEcapitalToUse,pointsToBoost,pointsTotal à parser


0.0.28 [17 Janvier 2013]
- Ajouté method Map.getFightCount() pour utiliser dans le packet fC
- Ajouté plein de method dans Condition pour parser des expressions
- Modifié GInventory.checkAllEquipedItemConditions grâce aux nouvelles methods dans Enums.Condition
- Les conditions marchent plus ou moins, il en reste plusieurs à faire.
- Ajouté if(movingItem.isAccessory){GM_MODIFY} dans l'ObjectParse
	  pour actualiser l'affichage du perso s'il bouge un item accessoire (coiffe/cape/arme/fami/dd/boucli)
- //TODO CORRIGER  ALIGNMENT_CHARAC("CA"),   (Dans Enums.Condition)
	  //TODO Condition valueCharac = p.getAlignement().getGrade(): (Dans Enums.Condition.parseExpression)
- Remplit classe GAlignement
- Ajouté un Alignement null aux gpersonnages	
- Changé la method ICharacter.getAlignement pour getAlignementSpecialization
- Delete les variables honor/deshonor dans GStats 
	  et mit dans l'hashMap avec les CharacteristicType 
	  et de nouvelles methodes pour les controler: getGrade 
	  	getHonor/setHonor/incremenHonort/decrementHonor ou dishonor et getGrade();
- TODO Dans les CharacteristicType y'en a une nommée ALIGNEMENT, 
	  peut-etre pour stocker la spécialization?
- TODO Finir les conditions: il en manque plein comme PX,PW,SI,PB  etc ... qui sont meme pas dans l'enum
- Ajouté mes classes CodeInput et Finders dans package Misc
- TOFINISH Les conditions fonctionnent pas mal: lvl, conditions de charac et autres, grosses expressions comme:  CS>10 & (CS<100 | CA > 5 | CW>10) & CE>10
- Ajouté method isParsableInteger dans Utils
- Ajouté method isEquiped dans GItem (pour ssavoir si ,Lobjet est équipé ou en POS_notEquiped)
- Réorganisé toutes les method dans ObjectsParser, optimisé, amélioré l'apparence et tout :)
- Ajouté Class CrystalParser avec le parsing du packet de boosting des stats 2.0
- Ajouté method splitItem dans GInventory
- Refait method equip/unequipItem pour ajouter la quantité en mouvement
- Modifié ginventory.getCanStack: ajouté que le stackeur ne doit pas être équipé
- Si l'objet est un objet divers (potion,prismes,pain...), 
	on ne vérifie pas ses conditions quand on le bouge en OM
- Mtn impossible de bouger un item en OM avec une qty <= 0
- Réglé un bug quand on delete un personnage qui demande la question/rééponse secrete:
	le parsing du packet prenait la substring représentant 
		l'input que l'joueur met en réponse secrete pour essayer de delete
		mais à substring(indexOf("|")+1, length()-1) alors que ca doit être length tout cours, pas de -1
- TODO : Controler la longeur des packets recus. (Ex: pour un changement de direction)		
- Changé quelques références à ItemEffectType pour SpellEffectType 
	vu qu'jsuis trop parresseux	pour trier toute les effets, ca va etre mieux comme ca
	+ Corriger la method getEffectByHexStringID dans SpellEffectType, elle retournait toujours null
- TODO: faire la commande .save (chat) [FAIT] et finir la commande save (console)	
- Modifié/corrigé le packet AH (onHosts) pour mettre la population et le type du CWorld		
- Commencé un nouveau systeme de queue pour controller les connexions sur le game
	Ajouté un champs config static dans GConfig.ConnexionQueue pour savoir si on utilise ces queues
	C'bizarre les queues et les Af, faudra revoir ça encore pour faire qqc de propre un jour ...
	Compliqué en tout cas.
- TODO: Continuer les pano jai comme un ptit probleme de marde avec mon grade/nbrD'Item.. [FAIT]



0.0.29	[18 Janvier 2013]
- Corrigé le bug pano, mtn tous les bonus s'appliquent parfaitement (À la sélection perso et au objectMove
- Ajouté la condition de ne pas porter deux fois le meme anneau dans une meme panoplie
- Corrigé un bug de sauvegarde de perso dans gperso.terminate: ajouté une vérification que le perso est dans le world avant de le save
- Ajouté commande de sauvegarde du personnage (.save) dans le ChatPlugin
- Modifié le ChatParser pour que le flood soit aussi controlé sur les commande de chat.	(Pour pas pouvoir flood .save/.shop/.start etc)	
- TODO: Faire les M et les Im messages 
- Fini les panoplies, manque juste le packet OS+- pour afficher le bonus de pano dans l'inventaire.	
	Ajouté class EquipmentItemSetTemplate extends EquipmenItemtTemplate
	Ajouté class WeaponItemSetTemplate extends WeaponItemtTemplate
	Ajouté methods get/setItemSet dans IItemTemplate
	Ajouté table itemsets dans syn et world. c'est la meme que ancestra à part que l'ID est en smallint au lieu de int
	Ajouté chargement des ItemSet dans SQL.Items.loadItemSet
	Ajouté etc etc
- BUG tanto jai essayé de me co à un serveur (2clic) et ca faisait chargement sans rien faire dautre.
	alors jai fermé dofus et revenu et là peut pas co au login  il me dit: "Déjà en connexion. Veuillez réessayer."
- Corrigé un bug dans codeInput.getStringRegion
- Ajouté toutes les armes à deux mains dans la bdd itemtemplates en parsant le item_fr_432
- Fini systeme de restriction d'armes à deux mains vs boucliers 
- Maintenant impossible de jeter/supprimer un objet de quête
- Changé l'ArrayList<GItem> dans GBank pour une HashMap<itemID, GItem>
- Pogné les itemTypeID de tous les items useable et targetable dans ExternalsSWF.Reader	
- Ajouté method isUseable, isTargetable, isUseableAndTargetable, isLiving, isMiscellaneous dans CItems
- Rename CItems.isEquipment en isEquipable
- Enlevé le isMiscellaneous à coté du checkAllCondition pour mettre isEquipable()==false
- Modif method objectCanBePlacedAtPosition. Seuls les items usable ou targetable peuvent être mits dans la barre de raccourci 
- Créé enum ItemType
- Ajouté method dans IItemTemplate: isCursed, isMiscellaneous, isRessource, isQuestItem, isLiving 
	+Implémenté dans EquipmentItemTemplate
	+Refait le EquipmentItemTemplate.isEquipment et isWeapon
	+Rename CItems.isEquipment en isEquipable
- En fait, on ne peut rien mettre sur la candyBar à partir du client, 
	c'est l'émulateur seulement qui a le droit de le faire à la suite d'une action
	dans le genre manger un bonbon ou se transformer en abra mutante.
		 (newPos >= POS_candyBar1 && newPos <= POS_candyBar8);	
- Y'aurait un isHiden (symbol h: dans le lang) à mettre dans IItemTemplate, 
	mais son symbol est jamais utilisé dans le items_fr_432...
- Corrigé bug quand un item n'a qu'une seule condition ça renvoyait que la condition était pas remplie:
	rajouter un else{parseOneExpression} dans parseAllExpressions
- Ajouté les tables itemsets/itemtemplates aux templates de BDD
- Ajouté method isClassItem dans GItem
- Ajouté setting du SpecialArg dans contruct GEffect et createNew
- Ajouté packet SB [SpellBoost] pour les panos de classe
- Ajouté l'envoie du SB dans les GStats.updateEquipmentStats et boostEquipmentStats
- Ajouté packet OS de panoplie
- Ajouté l'envoie du OS dans GStats.updateItemSetStats et boostItemSetStats
- Modifié le inventaire.getItemSetEquipedItems 
	qui retourne mtn les templateID[] des item équipés faisant partie d'une panoplie
- Ajouté method removeTralingZeros dans Utils
- L'affichage des bonus de pano et des boosts aux sorts par les items de classes est parfait 100%
- TODO: Changé le place le OS à la sélection du perso pour un peu plus loin 
	ou le mettre en schedulepacket pcq là le client l'prend pas en compte
- Ajouté method getBaseBoostHex dans Dice
- TODO: optimiser le systeme armes à deux mains vs bouclier dans inventaire.equip, ca prend trop de place à mon gout
- Ajouté method getNumberOfItems dans ItemSet
- Ajouté les ItemSetID des panoplies de classe dans CItems
- Pour les tutorials: ils ne s'affichent qu'une seule fois chacun
	y'a le type 1 qui envoie un tip lors de l'ouverture d'une interface
	y'a le type 2 qui envoie un tip lors de l'arrivée à une certaine map
- Dans gitem.isAccessory changé le objectCanBePlacedAtPosition(item, POS_ARME) pour : getTemplate.isWeapon().	
- TODO: Faire un truc de timer qui call la method getGWorld().getcWorld().update(this);	chaque minute genre
	pour updater la liste des serveurs (ca update la population du CWorld et envoie packet AH)
- TODO: Vérifier la validité des boosts pano/panoClass quand on delete/drop un item équipé



0.0.30 [19 Janvier 2013]
- Impossible de s'équiper/jeter/détruire un objet pendant un combat dont le state == FightState.ACTIVE
	dans GGameHandler.parseObjects
- Créé classe GExchangeBag
- Créé classe GAction
- Ajouté une GAction action = null; au personnage.  (Une action fasable à la fois)
- Ajouté method getExchangeBag dans GAction
- Ajouté byte type dans GAction et GExchangeBag
- TODO compléter classe GAction et GExchangeBag (Faire enum ActionType et ExchangeType)
- BUG de pano sur les stats en équipant/déséquipment des panos [CORRIGÉ]
- Corrigé une faille sur les items si on envoyait un packet pour equip/unequip 
	(ex) un anneaeu en double: OMitemid|posAnneau|2
	ce qui mettait les deux anneaux équipés au meme endroit
	et ensuite dans tout ce tralalla ca faisait des failles de duplication et de bug
	Maintenant on ne peut équiper un item équipable qu'à raison d'une qty = 1
- Corrigé l'affichage des bonus de pano à la sélection du personnage
	(dans perso.onselect en mettant le updateEquipmentStats apres le ASK au lieu d'avant.)
- Ajouté champs active_stats2 dans config bdd + activeStats2 dans GConfig
- TODO: Faire le truc du AH avec le GServer.update
- TODO: Faire les paliers de stats 2.0
- Corrigé les +pods (exemple sur les sacs) 
	C'est pcq le gstats.boostEquipmentStats n'ajoute les effets dans les stats 
		QUE si l'effet est associé à une charac
	Donc les pods ne sont pas inclut là dedans. 
	Seuls les effets associés à ce qu'il y a dans l'enum CharacteristicType sont ajoutés aux Gstats
- TODO: Corriger tes isUseable/targetable 
	pis faire dequoi pour arranger toute ca 
	pcq si ca strouve t'aura jamais les effets de ces items là	
- TODO: Restriction sur les chats alignement(5second)/commerce(2min)/recrutement(1min) lvl 6 + abo
- Pour la "PLUPART" des objets useable tu peux faire "exécuter les effets" + "objet.qty-1/détruit"
	Mais srx... cest de la merde...Les actions de mathias sont une bonne idée.
	Surtout les dons qui en ont plusieurs dans useable ET targetable 
	En passant il y a juste les poissons/viandes comestibles qui soit useable, les autres sont des ressources
	
- Faire une BDD pour les effets pour qu'ils soient rechargeables dynamiquement
	ainsi qu'un plugin qui s'occupera de les appliquer en combat/autre
	Comme ca si j'veux j'peux créer un nouvel effet 
		et ajouter ses fonctions dans le plugin sans reboot. 
	Alors soit tu met ton enum dans le plugin, 
		  soit tu transfere l'enum dans bdd login 
		  	et un ajoute aussi une table pareil dans le game pour que les serveurs ajoutent leurs effets
	HA NON THATS IT: pour la table des effets que les serveurs peuvent ajoutés, 
		on pourrait faire une colonne "script" qui contiendrait le script à exécuter pour appliquer l'effet
		magie!j'peux faire du scripting! des effets hyper dynamiques! les serv créent leur propre effet!
		Mais faudrait quand meme que j'controle les scripts qu'ils mettent 
			pcq sinon qqn pourrait une boucle infinie pis faire buger l'emu donc tous les autres serveurs
			Au pire si c'est possible: Mettre un timeOut de 0,1seconde sur l'exécution de l'effet
				et si en 0,1s l'effet n'a toujours pas terminé tant pis,  il n'est pas appliqué
			  ( Style un thread donne le script à un autre thread et attend qu'il réponde,
	         si le premier thread n'a pas de réponse de l,autre en 0,1s, l'action de lautre est supprimée)
	Ouais fack ca ca pourrait être une option en plus qu'on pourrait rajouter.
	Mais garde l'idée du plugin comme idée principale, c'est ce qui convient le plus pour commencer
		Ensuite on pourra rajouter le scripting et ca sera le plugin des effets qui s'en occupera
					
- TODO: Ajouter l'effet MONTER_DESCENDRE_MONTURE(949,'/')  à l'item  7799 "Le saut sifflard" (le sifflet pour monter/descendre de la drago)
		Ajouter l'effet RECUPERER_OBJET_ENCLOS(947,'/') à l'item 8010 "Le démonteur"
		Ajouter l'effet OBJET_ENCLOS(948,'/') à tous les objets placables en enclos (foudroyeur batteurs etc)
		Voir pour ajouter l'effet RECUPERER_OBJET_ENCLOS(947,'/') à qqc, j'sais pas quoi
			et les effets 930 à 937 style "augmente sérénité, endurance...(DragoD)"
		AJOUTER L'EFFET E[950] = {d: "Etat #3", c: 71, o: "/"};  AUX RP_BUFFS ET AUX DONS (jpense)
		AJOUTER L'EFFET E[951] = {d: "Enlève l\'état \'#3\'", c: 71, o: "/"};  AUX RP_BUFFS ET AUX DONS (jpense)	
		Effet E[811] = {d: "Tour(s) restant(s) : #3", c: 0, o: ""};	pour les items qui s'enleve apres des combats 
			(certains RPBUFF s'enleve apres un combat et les bonbons 30 combats)
		E[731] = {d: "Agresse les joueurs de l\'alignement ennemi automatiquement", c: 0, o: ""}; -> Dons je crois, avec les ordres d'alignement
		E[760] = {d: "Disparaît en se déplaçant", c: 0, o: ""};
		
		BREF PASSE L'ENUM DES EFFETS EN REVUE ET AJOUTE LES AUX OBJETS SPÉCIAUX QUI LES ONT PAS
		 j'va l'avoir esti ;)
- FIXME: RAM : cétait rendu à 38 MB tantot ! 20Mb juste en byte[] !
- TODO: Ptete faire un truc pour merged tous les effets qui sont identiques 
	Parce que sinon tu vas avoir des tonnes d'effets/sorts+items/perso pis la RAM va se suicider.
	On appelle ca du partage de données ;) 2 références/8 bytes = bcp mieux que 2 geffects/96 bytes ;) (total)
	Faudrait une list/map des geffects instanciés avec un ID pour chaque geffect différent (ou ptete pas besoin d'ID, on verra..)
	La map serait faite ainsi : HashMap<effectTypeID, <List<GEffect>>>
	Au pire ca pourrait ptete meme etre une HashMap<effectTypeID, HashMap<valeurMin, geffect>> 
		pour mieux s'y retrouver
		C'est sur que les effets du genre un nom de drago on les met pas la dedans, c'est useless
		mais pour qqc comme +1 intel ca pourrait être bon de partager le meme objet geffect 
			entre plusieurs gitem (Dans ce cas des petits parcho d'intelligence ;) )
	(Un ID d'instance, pas l'effectID. pareil que un id de perso)		
	Le gitem référencierait donc à ces geffects au lieu d'avoir ses propres geffects.
	-Si on enleve un geffect de l'item: enleve la référence au geffect dans la liste d'effets de l'item et: 
		soit checker avec un observable si y'a dautre trucs qui référencient à ce geffect, 
		soit faire la map en weakreference pour qu'elle empeche pas le GC de delete les effets inutilisés
	-Si on modifie le geffect: Créer un nouveau geffect (check avant si y'en a pas dautre déjà fait de pareil), 
		l'ajouter à la liste de geffects globale et	
		checker si on peut enlever l'ancien si rien s'y réfère
	-Quand on créé un item: check par l'effectTypeID dans la liste si y'en a un qui correspond à ce qu'on veut
		et sinon créé un nouveau geffect + l'ajouter à la liste.
- TODO: Ajouter le parametre "j" à tous les SpellEffectType, c'est lui qui détermine s'il ya un jeu sur l'effet
		Donc sur certains effet on pourra laisser le Dice à null et ne pas l'envoyer dans les packets.
		Check dans le lang effects_fr_259 le parametre j=true 
		et la function dofus/datacenter/Effect.__get__description ;)
	Faudra ptete ajouter le parametre 'e' aussi pour avoir l'élément associé à l'effet (eau,feu,terre,neutre,air, c'pas exactement les charac)

- Créé classe EffectsShare pour la partage et le cache des geffects créés pour minimiser la création de 98765 geffects identiques
- Completement changé la manière de créer les geffects avec le nouveau systeme d'EffectsShare
- Créé abstract classe EffectPluginListenerImpl qui impltémente l'interface PluginListener dans la libraire Plugins faite à partir de mathias
- Créé classe EffectsManager qui a une variable référencant 
	à l'implémentation du EffectPluginListenerImpl par la classe Application dans l'EFfectsPlugin
- Ajouté methods ds EffectsManager en static pour pouvoir avoir accès aux fonctions de l'EffectsPlugin:
	getEffect(id), getEffects(), getDamagingEffect(id),etc, isPodsEffect, containsDurability(ArrayList<Geffect>), etcetc 	 
- Créé plugin: EffectsPlugin: c/c enum SpellEffectType, créé class Application, créé class Main extends plugin
- Ajouté les cases de quelques effets dans la classe Application
- Ajouté un systeme de scripting à l'aide d'un scriptEngine
- Ajouté un effet permettant d'exécuter un script sur demande dans le switch de la method Application.apply
	(id 1001: EXE_JAVASCRIPT, le nom du script.js doit être placé dans le specialarg de l'effet)
- Ajouté l'effet MAKE_INVISIBLE aux prismes de conquête dans bdd (enleve le, cjuste pour test & fun)



0.0.31 [21 Janvier] (J'ai oublié de faire la séparation entre le 19 et le 20)
- Corrigé le GItems.isEtheree qui ne regardait meme pas si l'item était une arme (c'aurait pu être un objet d'élevage)
- TODO: Faire un truc de removeLater() comme une scheduledTask pour .terminate le perso seulement plus tard, 
	au cas ou il se reco dans 2min ou meme 30min, pour pas avoir besoin de tout save/décharger/reloader à répétition. 
	Surtout si qqn flood connexion. En plus là c'est même quand on fait juste changer de perso ca charge/décharg/charge/décharge chaque fois..
- Ajouté les hasDice (le parametre j: true dans effects_fr) dans l'enum des SpellEffectType
- Enlevé le timer de regen automatique, corrigé le packet ILS + ajouté un ILS(this, 1000) dans perso.onSelect
- TODO: Finir les SQL des objets d'élevage quand on sera là-dedans 
- TODO: Refaire le systeme de regen de vie (ILS/ILF)
	Ne pas oublier de faire un getStats.incrementPdv quand le joueur arrete de gagner de la vie auto hors combat
- Corriger des bugs sur l'EffectsShare /la création d'items+effets
- Créé interface IEffectParams
- Créé classe Jet  + ajouté methods get/setValue, getValueHex + constructeur
- Implémenté IEffectParam dans Dice et Jet
- Ajouté methods isJet, isDice, getDice, getJet, getString() ds IEffectParam + implémenté dans les classes
- Ajouté vérification dans stats.incrementPdv que le int add soit pas > Short.MAX_VALUE
- Testé un script qui envoie un message de 3370 chars 9600 fois, ca prend 12XX ms à faire. (mathias fait bcp moins de 1000)
- Ajouté un script "errornoscript.js" pour dire au caster de l'effet que le nom du script ds le specialArg == "0" donc invalide.
- Mit la method SQL.closeResultSet en protected au lieu de private ... 
- Ajouté plein de closeResultSet(RS) dans les classes du package SQL pour bien fermer mes ResultSet et mes Statements
- Enlevé la method executeTask avec le switch et le thread.getName() dans ModalT 
	et laissé seulement le executeAbstractTask, ce qui prend moins de ram, 
	surtout over time vu que ces threads n'arrêtent pas de rouler en boucle ;)
- 	


0.0.32 [22 Janvier 2013]
- Commencé à apprendre l'AOP avec AspectJ
- Commencé un plugin utilisant AspectJ
- Ajouté un script pour les effets de dommages élémentaires basiques (DamagingEffects 96à106)
	Testé en me frappant avec un objet denclos, ca marche, manque juste la formule de dom
- Commencé le nouveau package de threads avec les Executors.
- (21h08) Fini le nouveau package de threads.: 
	- Créé Package NewThreads + exclu l'ancien package Threads
	- Créé classe ThreadsMangager
	- Créé class Task implements Callable + ajouté le code que j,avais avant din scheduleTask (un peu modifié)
	- Créé classe RejectedTaskHandler implements RejectedExecutionHandler pour handler l'exception quand on ajoute une schedule à une pool alors que la pool est déjà pleine
	- Ajouté un objet ThreadsManager à chaque GServer
	- Ajouté une ThreadPoolExecutor et une ScheduledThreadPoolExecutor au ThreadsManager
	- Ajouté method newScheduledTask, newDirectTask, waitAndOff, off au ThreadsManager
	- Changé les buffer ArrayList du ChatParser en Map<GPerso, ScheduledFuture>
	- Refonte du ChatParser: fait avec des call à newScheduledTask pour mettre des ScheduledFuture en hashmap, c'qui permet de controler le moment ou le gars repeut parler et de savoir dans combien de temps il va pouvoir parler
	- Ajouté le systeme de removeLater():
		- Ajouté method removeLater() dans GClient
		- Modifié le GClient.kick pour enlever la termination de là et callé removeLater à la place
		- Ajouté une HashMap<accountID, ScheduledFuture> clientsToTerminate dans LServer 
		- Ajouté une nouvelle SchedulingA: TERMINATE_CLIENT qu'utilise le removeLater() pour terminate le gclient,account et les persos
 		- Ajouté une nouvelle condition dans Task avec le code pour terminate: gclient+account+persos+inventaires et cie
 		- Modifié la structure du LAuthentificationHandler pour prendre compte des comptes qui sont dans la liste de comptes à terminate
 		- Modifié le LWorld.isAccountConnected() pour return l'ID de l'account s'il est dans la liste de compte du LWorld
		- Enlevé le chargement du compte s'il est déjà chargé dans le LWorld (en modifiant la structure LAuthentificationHandler)
		- Ajouté un truc pour enlever le compte de la liste à terminate LServer.clientsToTerminate quand il se reconnecte
		- Modifié le GHandler.messageReceived au packet AL pour ne plus charger la liste de perso du serveur s'ils sont déjà chargés
		- Modifié le gperso.onSelect pour ne plus charger le perso,ses stats, sa banque et ne plus caller updateEquipementStats ni le world.addPerso(this) 
		- 
- Profilé le tout avec les nouveaux executors et le removeLater():	
	- 101 ms pour reconnecter un compte+perso sur le game (30ms de Syn.d et 40 de SM.Sender.send)
	- Il y a l'air d'avoir quelques problèmes sur la ram qui aurait des leaks: 
		- Apres m'etre déco et que la task de removeLater se soit faite + GC, il restait une instance de GPersonnage existante .. :/
- Cherché pour faire un pluginloader perso pour l'AspectJ plugin (l'actuel peut pas load des classes en AOP)	
- Trouvé qqc de pas pire avec le Load-Time Weaving, :
	- J'peux ajouter mon AspectJPlugin à Syn comme si c'tait une lib 
	- Et sa mainmethod se lance en même temps que Syn	
	- Par contre pour recharger pendant le runtime, jpense pas ca soit très possible u.u
	- J'pense que j'peux au moins dire à mon AspectJPlugin (grâce à un pointcut) 
		- de faire ses actions principales (chais pas, comme quand on start lemu lol) 
		- à un certain moment avan/apres une method..
	- Testé avec la nouvelle Run configuration, ça marche bien mais bon, c'comme j'ai dit ...	
	- OMG le pluginloader charge bien le plugin, mais apparemment impossible de le recharger, c'bizarre
		- + C'est impossible de lancer Syn sans la configuration "Avec Weaver" pour loader c'plugin
-


0.0.33 [23 Janvier 2013]
- tpe.getThreadFactory().newThread(null).pause/restart. 
	-> Si on implémente notre propre ThreadFactory,
		- Ca devrait être possible de mettre des threads pausables/restartables comme avec mon ModalT
	- Peut-être aussi d'autre choses à implémenter comme le ThreadPoolExecutor..
- Ajouté commande ChatParser
- Fait des test de synchronization, d'appels et de for:
	- Ici, meme avec 2 persos sur la map, le getSpritesSynchroFull est accessé juste une fois
	- for(ISprite z : map.getSpritesSynchroFull()){
- Commencé les GActions:
- Ajouté method GA dans Sm.Game, TODO [FAIT]
- 	
- Commencé les sorts: 
- Créé class GSpell, ajouté du stuff de variables dedans 
- Créé class SpellsCache avec une hahsmap de sorts		
- Ajouté method getSimilarSpell dans SpellsCache
- Créé class SQL.Spells
- Ajouté method load(id, dbName) dans SQL.Spells
- Ajouté method getSpell dans GlobalWorld
- Ajouté hashmap de sorts dans GWorld et LWorld + les methods qu'ils faut pour prendre les sorts
- Delete la classe SpellsCache, ca m'aura servit dexpérience
- Ajouté constante minimumIDinWorldSpellsTable = 5000; dans CServer
- Ajouté plein de constantes de sorts dans CSpells
- Ajouté le chargement des sorts de classes au lancement de l'emu dans le LWorld
- Créé Enum PlayerState
- Ajouté methods searchIfGlyph,searchIfSummons,searchIfTrap dans GSpell
- Ajouté method isGlyphEffect,isSummonsEffect,isTrapEffect dans l'EffectsManager 
 	- + L'implémentation dans l'AbstractEffectPluginListener dans l'emu et dans Application dans le plugin d'effets
- 


0.0.34 [24 Janvier 2013]
- Continué les sorts
	- Continué le GSpell.apply
	- Continué le constructeur de GSpell
	- Ajouté le chargement des GSpell principaux en static dans le LWorld
	- Ajouté les probabilités d'appliquer tel ou tel effet dans un sort (Style roulette)
	-  
- Continué les GameActions: passé beaucoup de temps à lire dans le client
- Ajouté une String specialArgs aux GAction
- Ajouté une String specialArgs à l'enum GameActionType
- Ajouté un générateur d'ActionID dans le GWorld (pareil que pour les persoID, itemID...)
- Créé class GBuff
- Créé Class AbstractActionPluginListener et ActionsManager dans Externals.Plugins
- Créé l'ActionsPlugin qui pourra aussi utiliser du script pour effectuer des actions spéciales :3
- Ajouté commandes "MYID", "PERSOID" "GETMAPSPRITE"
- Packet SM.Game.GA(Perso, GAction) fonctionnel :)
- Ajouté pas mal de doc dans mes sources du loader client
- Ajouté quelques champs dans l'enum GameActionType
- todo ajouter les messages privés. Ex de RECV:  BMLeo|Salut, ca va?
- todo faire les amis, les cadeaux à la connection, continuer les actions
- todo quand qqn est kick par inactivité, on le voit encore sur la map apres à cause que cest ds removeLater()
- todo faire une meilleure spellList pour le perso et les monstres aussi d'ailleurs avec les positions et ceux qui sont pas "équipés"
- todo continuer le parsing du packet SMxxx|x pour change rla position d'un sort grâce au todo précédent
- corriger la queue, au moins faire un truc qui update en envoyant un packet chaque 5s à ceux qui sont pognés dedans
	- http://img341.imageshack.us/img341/4880/bugqueue.png
- Corrigé le bug du removeLater avec le perso qui s'affichait encore sur la map après être déco:
	- Enlevé le updateSpritesList(REMOVE, thisperso) dans perso.terminate et l'ai mit dans le gclient.kick	
- Ajouté l'action de demander un défi, quand on le fait ça envoie un message chat disant:
	- "bidule te demande en challenge" et "vous avez demandé trucmuche en challenge" juste pour test
- Ajouté une action (id 3) pour exécuter du javascript comme avec les effets x) 
	- (Mais fait attention à ça, qqn pourrait envoyer un packet GA003 et activer le script..)
- todo : introduire le isAway() sur les personnages et ne pas oublier la régénération de l'énergie en mode deco    (ds tarvernes, maisons...)
- todo oublie pas de refaire le systeme de régénération de vie automatique avec ILS/ILF
- Ajouté parsing de l'action de demande de défi
- todo vérifie la sécurité sur les recv de: gameAction, itemOnUse, etc...
- todo, continuer l'enum de game actions


0.0.35 [25 Janvier 2013]
- Ajouté la table de spells à la bdd login
-


0.0.36 [29 Janvier 2013]
- Bcp de recherche a été faite sur les manière de distribuer un cache avec un accès possible à partir de multiples JVM pour accéder aux mêmes variables
- TODO: finir d'ajouter parametre isWeapon dans ActionsManager.apply et cie. Ou ajouter parametre GItem item avec lequel on pourrait tout faire
- Commencé un nouveau systeme pour les actions sur les cells des maps (triggers + dalles...)
	- Ajouté ArrayList<gActionListener> cellActionsListener dans GlobalObjects/Map.java 
 	- Créé classe gActionListener dans Misc qui implémente ActionListener
 	- Ajouté method verifyCellActions dans Map pour vérifier + appliquer les actions sur les cells de la map
 	- 
- Corrigé les closeResultSet(RS) dans SQL.Items, certains étaient mal placés et pourraient faire des bugs


0.0.37 [30 Janvier 2013]
- Modifié le Map.verifyCellActions (+ rename en verifyMapActions) 
	- Ajouté un paramètre pour vérifier+exécuter seulement un certain type d'action
	- Ajouté des exemples d'utilisation dans la doc de la method, 
	- Maintenant, au lieu des "cellsActionsListener", on a "actionsListeners" tout court, c'qui permet d'en avoir pour:
		- la fin d'un combat (donner item, tlp en donjon, etc)
		- l'arrivée sur la map (animations de pnjs par exemple, achievement, quete (l'objectif découvrir la map/zone))
		- l'arrivée sur une cell (dalles ouvrant une porte, comme à l'entrée du donjon incarnam et kralamour)
		- l'utilisation/activation d'un objet interactif ? 
		- jeter un objet à terre? on peut vraiment mettre des listeners avec des actions pour tout et n'importe quoi :P


0.0.38 [4 Fevrier 2013]
- Ajouté le GEffect.createNewForSpell
- Ajouté la création des effets sur les spells dans GSpell.createNew
- Ajouté nouvelle constante dans CPerso : numberOfBasicClassSpells = 20; Utilisé dans l'LWorld au chargement des données statiques
- Ajouté la classe Misc.StringUtils de mathias (thx<3)
- Ajouté method indexOf(String str, String toSearch, int XiemeIndexOf) dans Misc.StringUtils
- FIXME: Man, le Exception.throwXXXException fait pas toujours déco le perso -.- (ex dans le parsing de SB, si on essaye de booster un spell lvl 6(p.ex.))
- Ajouté champs sql game config:  boolean kick/banOnPacketCantParse 
	- pour savoir si on kick et/ou ban lorsqu'un packet que le client envoie est imparsable 
	- (ce qui implique une tentative de cheat/hack 
		- dans le cas ou l'émulateur controle tous les cas de figure normaux)
- Impossible de booster un sort qui est déjà à son niveau maximum ou plus haut.
- TODO: packet SLo ou chais pas quoi, 
	- le packet envoyant la spellList et faudrait aussi celui pour les spellPositions
- Mis en commentaires de plusieurs Syn.d() fatiguants.	
- FIXME: Ajouté methods comme removeSpellByID dans GPersonnage
		
 		
0.0.39 [5 Fevrier 2013]
- Créé classe Classe.java représentant les variables de chaque classes disponibles sur le serveur
- Ajouté ArrayList<Classe> classes	dans GConfig pour contenir autant de sorte de classe de personnage qu'on le veut.
- Créé table classes_config du coté world pour configurer les classes disponibles sur le serveur et leurs params.
- Modifié GStatistiques.createNew pour mettre un genre de perso.getClasse.getStartStats/getGainedStatsPerLevel
- Enlevé les startLvls, startkamas, etc et toutes les methods en rapport pour les mettre dans Classe
- Ajouté method loadClasses(serv) dans SConfig pour charger les configurations des classes de perso
- Corrigé la method removeSpellByID pour bien enlever le sort de l'hashmap, avant ça le faisait pas.
- Modifié la method gperso.getSpellListString pour choisir si on veut mettre les positions des sorts en Hash (pour le packet SL) ou pas (pour la save)
- Créé source folder Objects pour contenir les packages d'objets: ConfigurationObjects, GameObjects, GlobalObjects, LoginObjects
- Créé package ConfigurationObjects pour contenir, par exemple, la configuration des Classe de perso, config de chais pas quoi dautre encore de possible
- Ajouté une String array HASH dans Utils avec une method getHashedValueByInt pour avoir la valeur en HASH d'un int
- Ajouté dans l'enum SchedulingA: SERVER_PUB
- Ajouté method SM.Spells.SLo pour afficher/désafficher les options dans la liste de sort (comme booster un sort, savoir le cout en points pour booster, etc)
- Ajouté l'envoie du packet SL (SpellList) à la sélection du personnage
- Ajouté l'envoie du SLo à la sélection du perso. SLo+ toujours et SLo- juste après si l'arme du personnage contient un effet d'incarnation (id 669)
- Ajouté method isIncarnationEffect dans EffectsManager et AbstractEffectPluginListener et implémenté la solution dans l'Application de l'effectPlugin
- Ajouté une method newScheduledRepeatedTask dans ThreadsManager pour créer des tasks répétées
- Ajouté Runnable en implémentation sur la classe NewThreads.Task pour créer à la fois des Callable et des Runnable à partir de Task
- Ajouté method getRunnable() et getCallable() dans class Task. Ça fait juste return this sous différent formats.
- Ajouté l'application de l'action SERVER_PUB dans la classe NewThreads.Task pour envoyer un message à tous les connectés
- Ajouté un threadsManager.newScheduledRepeatedTask(SERVER_PUB, 30seconde, "Bonjour à la population. Bonne journée", "FF0000", this) dans GServer pour créer un schedule envoyant un message à tous les connectés à chaque 30 seconde (On peut choisir aussi à partir de quel moment tu veux ça commence à repeat)
- Enlevé le this.action = null et this.params = null à la fin de Task.call() pour permettre les tâches répétées.
- Ajouté method isIncarnation dans GItem
- Ajouté l'envoie du SLo quand on équipe/déséquipe une arme d'incarnation (Dans GInventory.equip/unequipItem)
- Modifié les variables de GBuff, l'ai ai mit en private 
- Enlevé le boolean applyBeforeOrAfter dans GBuff pour mettre : byte applicationMode
- Ajouté les getters/setters dans GBuff avec de la documentation
- Ajouté method createNew dans GBuff, sans avoir test, ça m'a l'air fonctionnel de base. [TOTEST] faut lmettre en application


0.0.40 [7 Février 2013]
- Corrigé plusieurs .split dans le constructeur de Classe et des données dans les colonnes de la bdd qui faisaient buger
- Ajouté variable int recordConnexion dans GServer et l'ai actionné dans le GHandler.sessionCreate
- Créé classe Command dans ConfigurationObjects. Ces commandes seront autant utilisables en chat qu'en console, elles sont confondues et seulement différenciées par la condition "hasGMLvl > X"
- Ajouté HashMap<commandName, Command> dans GWorld
- Créé table commands_config avec colonnes : ID,name,actions,conditions,parameters
- Ajouté method createNew dans Command
- Ajouté method apply dans Command
- Ajouté method loadCommands dans SConfig pour charger les commandes qui auront été crées dans la bdd
- Ajouté un nouvel effet SEND_MESSAGE dans l'effectPlugin pour (p.ex.) les commandes du genre .infos, .tp, .commands
- Modifié le .apply du plugin d'effets (ajouter un param mapID) et du plugin d'actions (ajouté param GAction qui est créée avant au lieu de pendant le .apply et remodelé le reste) 
- Modifié donc aussi le GameParser.parseOnGameAction
- Ajouté l'application du nouveau systeme de commandes dans le ChatParser
- Ajouté champs dans la main config.xml : emulatorName="Syn"  emulatorCreatorName="Crystal"
- Mit le chargement de la sconfig, des classes, des commandes dans le constructeur des GServer (Avant la SConfig.load était faite dans le SQL.setUpConnexion)	
- Ajouté une HashMap dans l'enum des GameActionType pour plus de rapidité quand on va en chercher un à partir de son ID (À faire dans les autres enums aussi)
- Ajouté un if(se.isNegative()) life *= -1;  dans l'EffectsPlugin.Application.apply  case MINUS_X_LIFE et PLUS_X_LIFE.
- Ajouté le parsing de l'effet 825 (Teleport) dans L'EffectsPlugin.application
- 

0.0.41 [8 Février 2013]
- Ajouté method countUntilIndex, countUntilIndexFromTwoSides, countFromTwoSides dans StringUtils
- Fait des tests sur string.indexOf() VS .lastIndexOf
- Fait des tests sur StrinUtils.count VS countFromTwoSides
- Fait des tests sur StrinUtils.countUntilIndex VS countUntilIndexFromTwoSides 
- Ajouté un objet ThreadsManager dans Syn pour en avoir un global
- Ajouté une nouvelle SchedulingA: EVALUATE pour caller une methode avec des paramètres si on veut. 
- Ajouté du threading sans le lancement de l'émulateur: passé à 0,4s pour start au lieu de 1s grâce au globalThreadsManager dans Syn et l'action EVALUATE
- Ajouté la vérification Condition.parseAll(this.conditions) dans le Command.apply
- Bougé le SConfig.loadCommands et loadClasses dans le constructeur du GWorld à la place de celui du GServer
- Commencé un .txt sur le fonctionnement complet de Syn dans Syn_data/
- Commencé à l'écrire sur une feuile de papier aussi, un résumé des classes/interfaces principales nécéssaires.


0.0.42 [10 Février 2013]
- Mit l'arrayList des Classe dans GWorld à la place de GConfig
	- Updaté les methods qui y faisaient référence.
- Mit boostEquipmentStats et boostItemSetStats en synchronized
- Fait du profiling principalement sur GInventory.(un)equip, GStats.boostEquipmentStats, Account.As, 
	- Faut booster ça :P, c'est intéréssant (genre moyenne de 25ms par boostEquipmentStats, moy.10ms par As, 2X pour .equip O.o, normalement le As prenait 0ms ) 
	- (J'ai prit des screenshot) Les method.invoke aussi sont trop lent (comme dans gghandler et CodeInput.callMethod)
	
	
0.0.43 [11 Février]
- Continué les L/GServ.off 
	- Changé le acceptor.dispose par .unbind,,,,il était temps que je l'aille ça -.- y'ont genre 0 doc sur apache>.>
	- Ajouté les x.clear et x=null dans le LWorld.terminate
- Ajouté constante Constants.minimalLevelForAlignmentChat = 3; (à mettre dans config bdd)
- Ajouté le fait que si le grade d'alignement du joueur est < 3, il peut pas parler en chat d'alignement	
	
	
0.0.44 [19 Février 2013]
- Ajouté variables type dans GFight
- Ajouté un check getFight == null dans le perso.onSelected avant d'envoyer le packet ILS de regen automatique	
- Refait le txt fonctionnementDeSyn sous Word avec une table des matières et tout ;p

0.0.45 [20 Février 2013]
- Créé toutes les configurations des classes de base dans la bdd (Grâce à SQL.SConfig.createClasses())
- Ajouté un maxPaPm aux Classe
- Ajouté methods getPA getPM dans GStatistiques qui prennent en compte le maxpa/pm à partir de la colonne de pa/pm TOTAL
- Modifié le GSpell.apply pour controler les pa en comprenant le maxPA de la classe du character
- Modifié le SM.Account.As et GStats.getPacket pour pouvoir caller getPa getPM avec la classe du perso.
- Ajouté method getClasse dans ICharacter, pour pogner la classe du perso facilement et  pareillement pour les prismse,percep,drago
	- L'utilité d'une Classe pour les prism,dd,percep: Controler leur statsPerLvl, spells, startstats, startitems, pods, etc
	- Faut simplement mettre un champs dans la config pour qu'on puisse savoir, 
		- à la création d'un perso, quelles classes le perso peut avoir. (Pour éviter le cheat qu'un perso aie la classe Prisme p.ex.)
- En train de créer un objet Config dans ConfigurationObjects pour remplacer la GConfig 
	- La GConfig, elle, ne sera qu'un ptit reader utilisé pour setter les parametres de bdd avant de faire SQL.setUpConnexions
	
0.0.46 [27 Février 2013]
- Commentaire Important pour LAUNCHED SPELLS: 
	- Les GBuffs (Les GBuffs extend GEffect) peuvent être utilisé pour contrôler les launchedSpells:
	- Style sort avec relance de 4tours:
	- Applique GBuff sur le lanceur avec comme param: idSort (dans l'ID d'leffet) et remainingTurns=4
- Modifié le Classe.maxPaPm en minMaxPaPm 
- Modifié le GStats pour controler aussi le minimum de pa en plus du max
- Corrigé le Pathfinding.PathUtils.getFreeCellsAround	
- Modifié PathUtils.getFreeCellsAround: changé le parametre	ICharacter pour un ISprite
- Ajouté method PathUtils.isInLineWith(cell,cell) + des .png paint dans Syn_data pour imager le fonctionnement
- 

0.0.47 [28 Février 2013]
- Ajouté un ConfigurationObjects.Config.validateServerPort callé dans SConfig pour ne pas on si le port est déjà prit par un autre serveur.
- Modifié le Syn.startGameServers: 
	- les gameServer ne sont même plus instancié si on l'a set à open=false dans la config pour quelque raison	
	- La raison est que si le worldID est inexistant, le gserv créé n'aura pas de gworld, faute de cworld.
	- Donc pour starter un serveur à distance, faudra setOpened(true) et faire new GServer.start
	- Et aussi le Syn.gameServers[] devient une arrayList donc pour éviter d'avoir des valeures null ds liste	


0.0.48 [2 Mars 2013]
- Ajouté method parseOnGameActionKorect (recv GKK quand le client a fini d'exécuter une action)
- Ajouté ArrayList<Trigger> dans Map
- Ajouté method getTrigger(cellid) dans Map
- Modifié le GAction[] en Stack<GAction> dans GPerso (Thx Blackrushh pour l'idée)
- Ajouté method onMovementFinish dans Map

0.0.49 [4 Mars 2013]
- Modifié ObjectsParser.parseOnDrop: ajouté un gdo.setID(gworld.getNextItemID);  
	- (Pour que quand on le ramasse, il puisse se stack avec les autres items, 
		- avant ca bloquait à cause que sont stacker avec le même ID que l'item par terre 
		- vu qu'ils faisaient parti du meme stack avant de jeter)
- Testé le ramasse d'objet en GKK, ça marche parfaitement :P	
- Ajout de l'affichage de l'emote EAT_BREAD et DRINK_BEER lorsqu'on utilise du pain/bière  (dans ObjectsParser.parseOnUseNoConfirmation)
- Modifié le ObjectsParser.parseOnUseNoConfirmation pour n'avoir qu'un objet Sprite 
	- Et vérifier si c'est bien une instance de GPersonnage, sans quoi on return false;	
- Ajouté method onCancel() à GAction (TODO)
- Modifié parseGKK : ajouté le parametre de succès de l'action et 
	- onCancel si l'action n'a pas réussi
- Créé class Point  avec variables short x/y
- Créé class Cells et Path (Thanks BlackRush, j'vais étudier ça ;p)
- Modifié le ChatParser, ajouté un if(msg.length <= 0) return; dans le case general, après avoir enlever l'header de packet
- Ajouté le parser de Path + envoie du packet de mouvement dans l'ActionsPlugin onMovement !  (thx Blackrush)
- Modifié le parser de Path dedans ActionsPlugin.Application.onMovement, ajouté un path.add(0, new Node(p.orientation, p.cellid)); pour ajouter un node de la cell originale du perso
- [BUG] On peut maintenant déplacer son personnage sur la map avec des bugs 
	- Impossible de recommencer à bouger après un mouvement [FAIT]
	- Mauvaise gestion du GKE fait lancer des exceptions qui déconnectent [FAIT]
	- Mauvaise gestion du GKE  impossible de marcher après avoir cancellé      [TODO  BUG]
- Modifié le GWorld.getNextActionID : ajouté if(lastActionID == Integer.MAXINT){lastActionID = 0;}
- Modifié le ActionsPlugin.GameActionType.getAction(int actionTypeID) en getxx(short action)
- Modifié le GGameHandler, mtn toutes les method return boolean qui dit si on packetcantparse ou pas.


0.0.50 [7 Mars 2013]
- Fait pas mal de recherche sur la cancellation de gameactions: il n'y a que le type 1(MOVEMENT) qui peut être annulé
- Ajouté methods applyOnDone et applyOnCancel au ActionManager et à Application dans l'actionsplugin
- Modifié le GameParser.onGKK: controle de la string du packet et des données qu'il en ressort



0.0.51 [12 Mars 2013]
- Continué les GameActions.apply, onDone, onCancel
- Debug complet des déplacements sur la map (hors-combat)
- Ajuté method SM.Game.GA_MAP pour envoyé un packet d'action à toute la map.
- Le ramassage d'objets jetés par terre se fait parfaitement bien entre plusieurs clients. (A jete, B ramasse, tous les deux voient les actions et tout, 0 bug  )
- Ajouté method isOverweight dans GInventory pour savoir si usedPods >= maxPods
- Impossible de bouger sur la map avec usedPods > maxPods + Packet Im envoyé
- Modifié le onGKK: l'action nMest pas removed à cet instant, elle est mtn remove dans le applyOnDone/applyOnCancel (ActionsPlugin.Application)
- Modifié applyOnCancel -> Peut mtn canceller l'action sans faire les tâches habituelles (juste p.actions.remove(a) + send("GA0;0"))
- Créé enum ImPackets 
- Créé enum ImType à l'intérieur de ImPackets
- Modifié le SM.Infos.Im,   demande mtn un ImType+ImPacket+String au lieu de juste string
- Modifié les utilisations du Im (GPerso.onSelect et ChatParser en autres)
- Modifié EXTENDED_ALPHABET ou alphaNumericUnderscore pour qu'ils soient pareils. (Dans StringUtils) (À la fin, c'est bien le '-' qui faut mettre avant le '_')
- Ajouté un regex alphaNumericUnderscore dans Constants
- Modifié Node.parseNode: ajouté une vérification (regex) que les chars dans la string du path sont biens valides (alphaNumericUnderscore)
- Corrigé le PathUtils.getCellIDinOrientation, fonctionne bien maintenant. avant il faisait bug. (+ajouté param boolean fight)
- Modifié PathUtils.getFreeCellAround, ajouté param boolean fight
- Changé le GWorld.lastActionID de base à 1 au lieu de 0
- Modifié le onGKK, si l'ID unique d'action == 0, on return true sans exécuter d'action. 
	- (à cause du  send("GA0;0") quand on veut forcer une cancellation d'action)
- Remplit les colonnes Width et Height dans la table Maps dans bdd syn (login)



0.0.52 [13 Mars 2013]
- Ajouté constante d'enum ImPackets.InventairePlein 
	- et planté le fonctionnement du Im packet dans Map.onMovementFinish 
	- quand on essaye de ramasser un objet sur le sol et que l'inventaire est plein (trop de pods)
- [TODO] : transéferer le code de Map.onMovementFinish dans ActionsPlugin.Application.applyOnDone(Movement)	 [FAIT]
- [TODO] : Triggers + changement de map :P	


0.0.53 [18 Mars 2013]
- Déplacé le code de map.onMovementFinish dans ActionsPlugin.Application.applyOnDone.MOVEMENT comme il se devrait.
- Finalisé l'action de CINÉMATIC dans Application.apply pour le changement de map.
	- J'ai juste une peur, la perso.map est settée dans cette action, avant que la map soit chargée, au lieu d'après
	- Donc si le dédié des langs est lent et que le client n'arrive pas à charger la map, le joueur aura un double
	- Pcq sa perso.map est la nouvelle, mais il est encore dans la liste de sprite de l'ancienne map.
	- [TODO] corriger ça, 
		faudrait l'ajouter la liste de sprite (map.update(ADD_SPRITE,p) en meme temps que setter sa mapID
		[done] : non en fait ca ne buguera pas, j'en suis sur ;) s'il a un chargement trop long et qu'il se déco reco, il va spawn sur la targetmap et il ne restera plus rien de lui sur l'ancienne car il a déjà été retiré lors de l'action CINÉMATIC :)
- Ajouter une action de fin de mouvement dans GameParser.parseOnGI  (comme ça si ya un item jeté à l'endroit ou il spawn il va le ramasser)
- Ajouté method getMovementActionID dans ActionsManager->Application. -> return MOVEMENT.getType();
- [TODO] : refaire la commande LEVEL avec les gainedStatPerLevel qui sont dans la class_config
- Ajouté commande [[TEMPTRIGGER] targetMapID,targetCellID]
	- pour ajouter un trigger à la map temporairement (il ne sera pas save en bdd)
- Ajouté method push dans classe Path pour add et return this (path) (pour faire des chaines de method you know)
- Les changements de maps (utilisation de triggers) sont parfaits :)
- [TODO][TODO] voir c'quon fait avec les gActionListener et le map.verifyMapActions + l'arrayList de listeners dans map...


0.0.54 [19 Mars 2013]
- Ajouté des filtres à la liste de todos: passé de 1000 à 200 (les 800 autres étaient inutiles)
- Commencé à cleaner les 200 todos
- Ajouté method terminate à IObject
- Modifié le perso.terminate
- Modifié le Bank-GInventory-GStatiques.terminate pour convenir à l'implémentation terminate().  
	- On doit mtn enlever de la world.hashmap à l'extérieur du .terminate...après l'avoir terminate en fait
- Implémenté IObject (surtout les terminate sont tous faits) dans:
	-  GItem, GEffect, IStorage, GAction, LAccount, GClient, LGift, GWorld
- Ajouté method removeInventoryAndNull (& pour statistiques & bank) pour set null la variable et ensuite l'enlever de l'hashmap (Utilisé dans perso.terminate())
- Ajouté method .clear dans ChatParser pour clear toutes les hashmap de floodeurs
- Continué le GWorld.clearAll()   (pense avoir fini)
- Continué le GWorld.terminate()  (pense avoir fini)
- Ajouté un p = null dans Task.call(TERMINATE_CLIENT) juste apres le p.terminate
- Modifié le Task.call(TERMINATE_CLIENT), il call mtn le GClient.terminate implémenté d'IObject où j'ai bougé l'code
- Modifié le TitleManager.modify(CLEAN, null, 0...) ->  fais mtn this.xxx = new[0][0] au lieu de [1][1]
- Modifié le Account.setBanned(bool) en setBanned(boolBanned, boolSave)  (donc la ligne SQL.account.updatebanned est à l'intérieur de cette method)
- Ajouté un default:  c.getAccount.setbanned(true,true); c.kick; break;  dans le messageReceived du GHandler.
- Fini le LAccount.terminate ([TODO] sauf qu'il manque le sql.gifts.save(this.gift))
- Modifié le ItemTemplate.isEtheree -> pu besoin que ca soit une arme pour return true, juste l'effet durabilité
- Ajouté method getDurabilityEffect dans EffectsManager+Effectsplugin
- Ajouté une modification des packets d'affichage des GDropItem pour gérer les objet interactif (avec la durabilité visible)
	- [TODO] go vérifier la vraie structure qu'il faut donner au packet GDO dans les sources du client 
	- et tester le tout. [FAIT] (mais j'arrive pas encore à afficher la durabilité comme faut)
	
- BIG TRAVAIL DE FOU SUR LE SYSTEME DE LISTENERS
- Ajouté table SQL actionsListeners aux mondes
- Ajouté colonne actionsListeners à la table maps SQL du login et des mondes
- Ajouté champs WorldActionsListenersIDs à la config par BDD des mondes pour mettre les ID des listeners relatifs au world
- Bougé class gActionListener dans l'ActionsPlugin
- Créé class gActionListenerContainer dans l'ActionsPlugin
- Créé enum ActionListenerType dans l'ActionsPlugin
- Créé class AbstractActionListener dans Syn.Externals.Plugins
- Ajouté method SConfig.loadActionsListeners
- Modifié SQL.Maps.load -> ajouté param GWorld pour pouvoir caller le SConfig.loadActionsListeners
- Ajouté call à SConfig.loadActionsListeners dans constructeur GWorld()
- La classe SynActions devient une interface
- Toutes les enums dans l'interface SynActions implémentes maintenant SynActions
- Ajouté plein de methods dans Map en rapport à l'ArrayList d'AbstractActionListener
- Ajouté plein de methods dans GWorld en rapport à l'HashMap de <SynActions,AbstractActionListener>
- Si j'veux ajouter d'autres listeners à une method dans l'émulateur qui n'appelle normalement pas le notifyListeners, 
	- On a juste à la cibler et faire le notifyListeners grâce à l'AspectjPlugin. :)
- Ajouté des methods dans ActionsPlugin.Application  (ActionsManager + AbstractActionsPluginListener)
	- notifyListeners() : void;
	- createListener() : AbstractActionListener;
	- getActionListenerType(String) : SynActions;
- Si on ajoute/set une liste de listeners à un actionListener qui n'est pas un container, 
	- On créé un container avec les variables copiées de l'ancien listener, 
		- on lui met la bonne arraylist et on retourne le nouveau container.
- Ajouté 5 conditions :  + ajouté leur case dans le parsing de conditions
	- GLOBAL_ACTION_LISTENER("GL"),//GL=1 -> 1 = l'ID du listener qui faut qui soit complété pour return true;
	- MAP_ACTION_LISTENER("ML"),//ML=1 -> 1 = l'ID du listener qui faut qui soit complété pour return true;
	- CELL_OCCUPIED("OC"),//OC=345 -> 345 = l'ID de la cell qui doit être occupée pour return true;
	- CELL_OCCUPIED_BY("OY"),//OY=625 ->si la cellID du perso = la cellID de la condition (625)
	- MAP_OCCUPIED_BY("MY"),//MY=625 ->si la mapID du perso = la mapID de la condition (625)
	- AREA_OCCUPIED_BY("AY"),
	- SUBAREA_OCCUPIED_BY("SY"),
	- SUPERAREA_OCCUPIED_BY("SS"),
- Les ActionListeners en tout sorte appliquent maintenant des GEffect en plus des GAction
- Tested & Approved : CA FKN MARCHE LIKE A BAWS BITCH DU 1ER COUP   (sauf pour l'ajout de listeners par dessus d'autres listeners)



0.0.55 [20 Mars 2013]
- Corrigé le systeme de listeners quand on voulait transformer un listener en listenerContainer avec le addListener dans World,Map et Listener.
	- On peut mtn assigner des listeners emboités à d'autres listeners (ces derniers étant des Container).



0.0.56 [21 Mars 2013]
- Corrigé le packet GDO avec la durabilité (DropItem.getPacket genre)  [TODO] en fait non il ne marche pas encore.
- Ajouté les noms des ItemTemplate dans la table d'itemTemplate du login et des mondes
- [TODO] Tu pourrais faire les actions spécifiques de ON_ITEM_USE avec des actionsListeners en plugin.
	- Exemple pour les objets d'élevage, 
		-> envoyer l'affichage et tout de l'objet grâce à une action callée par un listener placé sur le World
- BIG PROBLEM à la suite de la commande 'load lbb',  
	- Ensuite en se reconnectant, au choix de perso, les persos sont tout nus (pas d'accessoires), morph féca, etc.
- Ajouté 2 conditions (dans l'enum) :  + ajouté leur case dans le parsing de conditions
	- ITEM_USED("IU"),//IU=7618  -> 7618 = ID d'item qui doit avoir été utilisé you know
	- ITEM_TYPE_USED("TU"),//TU=12 -> 12 = le type d'item template qui doit avoir été utilisé you know
- Ajouté un GameActionType: ON_ITEM_USE(1002) + le case dans Application.apply qui fais envoie un ptit msg pour l'instant
- Ajouté un ActionListenerType: ON_ITEM_USE
- Ajouté un paramètre IObject à toutes les methods de parsing dans l'enum Conditions 
	- Conditions.parseAllExpressions prend mtn un IObject en param (peut mettre null la plupart du temps)
		- Utile par exemple pour les conditions ITEM_USED, ITEM_TYPE_USED, etc. (Pourrait être des conditions comme SPRITE_TARGETTED aussi)
- Ajouté un paramètre IObject à ActionsManager.notifyListeners et ActionListener.isCompleted
- Ajouté des calls à ActionsManager.notifyListeners dans ObjectsParser.onDrop-Delete-UseNoConfirmation
- Ajouté un actionListener en bdd pour tester le nouveau type ON_ITEM_USE avec le new type d'action, l'param Iobject et tout.
- Enlevé le if(e != null) et if(a != null) dans la ActionListener.actionPerformed et modifié les références pour le traiter ailleurs.
	- TODO faire un check if( != null) au chargement des actionslistener (SConfig.loadActionListener)
- Modifié le Application.notifyListeners() -> ajouté des check !=null avant de faire list.add(world.getactionListener)
	- Ça règle les problèmes de nullpointerexception quyavait de ce coté là




0.0.57 [25 Mars 2013]
- [TODO] Créer la method gclient/lclient .ban();
- Delete la classe GGameHandler
- Créé un ParsingPlugin
- Créé package Abstractions dans l'package External.Plugins pour contenir les classes abtraites
- Créé package Managers dans l'package External.Plugins pour contenir les Managers
- Créé classe ParsingManager  dans External.Plugins.Managers
- Bougé l'array packetsToIgnore de GGameHandler à dans ParsingManager
- Créé interface IParser dans src.Interfaces
- Créé classe ParsingMain dans ParsingPlugin
- Créé package Parsers dans ParsingPlugin
- Transféré les anciennes classes de Parsers dans le ParsingPlugin
- Créé classes dans ParsingPlugin.Parsers: -> 
	- BasicParser, EnvironmentParser, RelationsParser, SpellsParser, AccountParser,
	- ConquestParser, DialogsParser, DocumentsParser, ExchangesParser, FightsParser, GuildsParser,
	- HousesParser, InformationsParser, JobsParser, KeyParser, PartyParser, PingParser, QuestsParser, 
	- RidesParser, TutorialsParser, WayPointsParser.
- Implémenté IParser dans tous les parsers du ParsingPlugin
- Créé method initiateParsers dans ParsingMain pour créer les instances de Parsers
	- et les ajouter à l'HashMap de IParsers dans le ParsingManager
- Modifié le GHandler.messageReceived dans la partie qui envoiyait le message au GGameHandler,
	- Call mtn ParsingManager.parse();	et call le if(!nobug) packetCantParse de là.
- Ajouté un parametre boolean alias à ActionsManager.notifyListener(string blabla)
- Modifié le ObjectsParser.parse, au lieu de return le boolean tout de suite, j'le mets en var
	- et l'utilise pour savoir si on call ActionsManager.notifyListeners(packet.substring(0,2), p, item, true);			
- Ajouté le Application.notifyListener(SynAction) à la classe abstraite et au manager
- Créé HashMap<String, ActionListenerType> actionListenersAlias  : dans ActionsPlugin.Application.
- Créé event Load_Plugins_ActionListenersAlias dans la lib Plugins, package MiscEvent
- Créé method initiateActionListenersAlias ds tous les implémentations de PluginListener ds tous les plugins
- Ajouté le registering/removing de l'event Load_Plugins_ActionListenersAlias dans tous les plugins
	- (Dans 'PluginMainClasse'.registerEvents et unRegisterEvents)
- Ajouté un call à registerEvents dans tous les Main des plugins
- Ajouté un objet du PluginListener de chaque plugin dans leur Main (Exemple une instance d'Application ou autre)
 	- Modifié le setGreatVars de tous les plugins en mettant le v.listener = à l'instance créée
 	- C'est juste pour pouvoir le controler mieux et plus visuellement.
- Enlevé les HashMaps de flooders de la classe ChatParser et les mit dans GWorld
	- Delete l'instance de ChatParser dans le world.
	- Ajouté method modifyFloodList, nullFlooders et clearFlooders dans GWorld
	- Modifié le GWorld.clear pour mettre this.clearFlooders au lieu de ChatParser.clear
	- Modifié le GWorld.terminate pour mettre this.nullFlooders au lieu de chatparser = null;	
- Modifié le paramétrage .getSpecialArgs.equalsIgnoreCase(iobject) en .lowerCase().contains(%iobject%) 
	- dans l'application des GAction des ActionListeners (gActionListener.actionPerformed)
- Créé paramétrage %addpersolist% dans les GAction des ActionListeners   (gActionListener.actionPerformed)
	- pour que si les param de l'action contienne ca, la GAction soit ajoutée à p.getActions().add(action);
- Ajouté le packet CWJ et CWV aux packets à ignorer dans le ParsingManager. 
	- (ouvrir et fermer l'interface de carte du monde)
- Ajouté method unload dans tous les Managers dans External.Plugins.Managers
- Ajouté method unload dans la lib Plugins, dans classe abstraite Plugin (celle qu'extend les Main des plugin)
- Corrigé mon bug de reloading des plugins, c'était à cause que les packages des plugins étaient sealed
	- (Quand on export), click next, next, et désactive tout sealing pour pouvoir runtime loading 
		- un package plusieurs fois avec des classes venant de plusieurs endroits. 
		- (Option Seal Some Packages et choisi aucun package)
- Corrigé un NullPointerException dans GEffect.getString si le iep était null.
- [TODO] À Corriger le reloading des objets ActionsListeners instanciés lorsqu'on reload l'ActionsPlugin
- [TODO] Réduire le temps de chargement de la GConfig
- Delete la classe CodeInput de Syn.src.Misc pour garder juste celle de la UtilsLib
- [TODO] Mettre des int à la place des shorts dans l'HashMap de stats dans GStatisques
	- Pcq hey, chaque Key d'entry dans l'HashMap prend 16 bytes + 2 pour short ou + 4 pour int
	- Fack pour vrai j'pense sérieusement que ca serait mieux, vu que ca changerait pgc coté ram ;)
	- Ha non ca prendrait genre 2000Mo de plus (5000 joueurs * 200 champs * 4-2bytes).. 
- Ajouté classe Randomizer dans UtilsLib




0.0.58 [26 Mars 2013]
- [TODO] À Corriger le reloading des objets ActionsListeners instanciés lorsqu'on reload l'ActionsPlugin
- Converti le GServer en implémentation IObject	
- Fait le LServer/GServer.terminate	
- Refait le LServer/GServer.off
- Refait le Syn.shutDownHook et Syn.closeAll   -> ajouté un parametre boolean terminate et full modif le hook
	- Le reboot et off avec ctrl+C se fait bien maintenant (sur la console du dédié on sentend)
- Renommé les tables itemTemplates en item_templates et itemSets en item_sets
- Modifié le GHandler.createPerso et GPersonnage.createNew
	- Mit la création du ginventory + gstats + spellList à l'intérieur du perso.createNew à la place du ghandler
	- 
- Ajouté method getStartSpells dans GWorld et aussi getStartSpellsAsMapWithPositions
- Corrigé un nullpointer dans GClient.terminateLater avec if(account != null){	
- Corrigé un nullpointer dans SM.Spells.SL, ajouté un perso.getSpells() != null	
- Changé la ligne dans l'i18n.xml : FRENCH = "French" pour FRENCH = "Francais"
	- Donc Changé la ligne rootNode.getAttributeValue("FRENCH"); pour :   (Dans la classe LangConfig)
			rootNode.getAttributeValue("FRANCAIS");	
- [BUG] Ex. deux personnes sur deux serveurs différents, 
	- s'ils vont sur la même map de login, 
	- bah ils se voient puisque y'a juste 1 instance de chaque map de login.
	- Faut une instance par gworld :( 
- Créé method getMapWithoutAutoLoad dans GWorld
- Modifié le sessionIdle et le SM.Messages.MS pour mettre le GClient en param au lieu du c.getAcc.curPerso...c'tait con -.-
- Changé tous les ID de maps en int y comprit l'HashMap dans le GWorld + GlobalWorld 
	- et les références à cette hashmap etc
- Corrigé des bugs à la création du personnage:
	- Ajouté le setting de la spellList dans perso.createNew, 
	- Ajouté la spellList dans SQL.Perso.create et dans son query
	- Si la fin de la création du perso (save le perso + stats + inventory en bdd) bug, 
		- il est delete et on renvoie à l'écran de choix de perso
	
	
- 
- Modifié le GlobalWorld.getMap, bcp mieux maintenant, meme si c'est pas super beau/clean pour les yeux,
	- On a maintenant une copie de chaque login map dans chaque GWorld au besoin
	- Si un gworld demande une map qui fait partie du login et qu'il n'a pas déjà d'instance de celle-ci,
		- il va voir dans les autres gworld et fait une copie + se l'ajoute s'il trouve une instance de la map
		- Sinon il va la charger dans la bdd login.
	- C'est bcp plus efficient 
	- Si on était 2 perso sur 2 serv différent, on ne peut plus se voir puisque ce sera 2 instances de mm map :)
		- Avant on utilisait une seule instance dans le LWorld donc on pouvait se voir entre les serveurs.
- Delete l'HashMap de maps du LWorld = les methods reliées à cette hashmap.
- Enlevé la colonne channels de la table classes_config
- Ajouté method setEmotes(byte[] emotes) dans GPersonnage
- Ajouté method setEmotes(String[]) dans ConfigurationObjects.Classe
- Ajouté setting des startEmotes dans GPerso.createNew -> p.setEmotes(getClasse(classID).startEmotes);
- Ajouté colonne emotes dans la table personnage
- Ajouté method verifyName dans GHandler et callé dans le createPerso, ca fait du ménage :')
- Ajouté packet SM.emotes.eL, .eA, .eR   + call à .eL dans le perso.onSelected
- Ajouté le param d'emotes dans le sql.perso.create et .update pour créer et saver les emotes de perso en bdd
- Ajouté method .copy dans Map qui renvoie une copie de la Map avec les Triggers et ActionListeners
- Corrigé deux nullpointer dans Map.copy();
- Rendu public la method Exceptions.write(exceptionName, exceptionMsg);
- Ajouté un call à Exceptions.write("", trowable.getMessage());  dans GHandler.exceptionCaught
- Corrigé les performances du SQL.Personnages.loadLastPersoID avec une requete MAX(ID) AS ID 
	- pour pogner le plus haut ID d'un coup au lieu du while d'avant
- Ajouté method create dans SQL.Accounts
- Ajouté method loadLastAccountID dans SQL.Accounts
- Ajouté command CREATEDEFAULTACCOUNTS dans le ConsoleListener pour créer X comptes de test automatiquement
- Créé 100 000 comptes de test sur le serveur de test sur le dédié linux CN
- Bougé plein de commandes du gm 10 au gm 9 dans le ConsolePlugin
- [TODO] Faire un champs config pour avec ça (pour pubs) : (c'tait dans GServ.start) 
	- threadsManager.newScheduledRepeatedTask(SchedulingA.SERVER_PUB, 30, 30, TimeUnit.SECONDS, 
			- new Object[]{this, "Bonjour à la population. Bonne journée!", "FF0000"});
- Ajouté un agent à la command line du emu.sh du dédié pour le starter avec YourKitJavaProfiler 9.0.9 :)
- Ajouté un case default à l'apply de l'Application du ActionsPlugin pareil que celui de l'effectsplugin		
- Complété le GSpell.createNew
- Ajouté methods de get/set des variables dans GSpell
- Ajouté variable classID dans GSpell
- Créé une classe Moar dans nouveau package Moar dans ActionsPlugin
- Bougé le GSpell.apply dans ActionsPlugin.Moar
- Ajouté le sort Coup de Poing à la base de donnée du login dans les spells
- Enlevé parametre ICharacter target à Moar.applySpell, 
	- ce sera plutôt une ArrayList de targets qui seront déterminés par la zoneType du sort.
- Ajouté parametre GItem arme à Moar.applySpell 
	- pour appliquer les armes de la meme manière que les sorts
- Ajouté champs pour sort Coup de Poing dans CSpells : public static final short specialSpell_CAC = 0;
- Ajouter ceci dans GPerso.getSpellByID() et GPerso.getSpellByPosition()
		if(spellID == CSpells.specialSpell_CAC){
			return getWorld().getSpell((short) spellID)[0];
		}
		
- Ajouté if(triggers == null || triggers.size() == 0) à Map.getTrigger(id)
- Ajouté dans Map une HashMap<Short, Short> cellParams = null;		
- Créé enum CellType avec WALkABLE(0) et LINE_OF_SIGHT(1)
- Ajouté chargement du sort Coup de Poing (CSpells.specialSpell_CAC) au démarrage du LWorld  (ds bloc static{})
- [TODO] Parsing des mapData des Maps et Moar.applySpell
- [TODO] Commencé methods Map.isCellWalkable et .isCellLineOfSightRequired		
- [TODO] Moar.applySpell : arme/s.getZoneType() -> getTargets()
- [TODO] Moar.applySpell : if(cc && arme) -> boost damages





0.0.59 [27 Mars 2013]
- Corrigé la formule pour le packet SM.emotes.eL, la liste se fait mtn parfaitement
- Ajouté method loadAllItemSets dans SQL.Items pour pouvoir charger tous les itemset au complet
- Ajouté method reLoadAllItemTemplates dans SQL.Items pour pouvoir recharger tous les itemtemplates qui avaient déjà été chargés dans un world ou dans un login
- Ajouté un if(Pattern.matches(Constants.Constants.isAlphaUnderscore, name) == false) dans GHandler.verifyName
- Ajouté dans Constants : public static final String isAlphaUnderscore= "^[a-zA-Z-_]*$";  (Pour vérifier qu'une string
- Ajouté method setLike dans IItemTemplate et implémenté dans toutes les sortes d'itemTemplate
	- Pour modifier l'itemtemplate pour qu'il soit identique à celui en param (set toutes les memes variables)
- Enlevé des if(patente != null) dans GlobalWorld.getXXX, ils étaient inutiles
- Ajouté un param boolean onlyReload à reLoadAllItemTemplates 
	- pour choisir de charger seulement les templates qui étaient déjà présent dans le g/lworld 
		- ou tout ce qui se trouve dans la bdd
- Ajouté method createIItemTemplateFromResultSet dans SQL.Items, le nom est explicite.
- Corrigé un bug sur le query updatePerso, il manquait " = ?" après le champs 'emotes'
- [TODO] Continuer les methods de reloading des tables bdd gworld dans BDDWorldTemplate
- Commande LOAD mieux faite: Ex qui amrche: load gitem_templates(null, true)
- Ajouté variable zoneTypeCC à GSpell
- Modifié GSpell. zoneType et zoneTypeCC -> maintenant des double array[][] de string
	- Ainsi on sépare mieux les zones de chaque effets et les zones normales de celles en CC
	- On peut mtn avoir plusieurs zones par Effet
	- On peut mtn avoir des zones dont le nom est plus de deux char (Ex: 'Goh' au lieu de 'Pa')
	- [TODO] Faudra modifier le client à fond pour implanter ça de son côté aussi pour l'affichage U_U
	- 

- Corrigé plein de sorts qui étaient mal écrits en bdd (c'est leur requiredStates qui bugaient)
- Changé le rateCC et rateEC en short au lieu de byte (Dans GSpell)
- Fini le GSpell.createNew
- Fini le GEffect.createNewForSpell et getStringForSpell
- Chargement des sorts maintenant parfait à 100%.
- Ajouté method loadAllSpells dans SQL.Spells
- Ajouté method compareStringArrays dans UtilsLib.Misc.Utils
- Ajouté method getZoneType(Gitem):String dans Constants.CItems
- Ajouté method getZoneTypeAppropriate(int indexEffect, boolean cc) dans GSpell
- Commencé method getTargetsInAreaString
- Continué method Moar.applySpell();
- Créé package Plugins.Interfaces dans Externals et mit IEffectType et IParser dedans
- Créé enum ZoneType
- Ajouté les method dans PathUtils: getTargetsInAreaString/s,  isInLineWith2, getOrientationBetweenCellsInFight, getDistanceBetweenCellsInFight
- Ajouté static array[] diagonals et orthogonals dans l'enum Orientation avec des methods de getters
- Enlevé le paramètre short targetcell dans la method EffectsPlugin.apply  + modifé les références à celle-ci
	- + enlevé les merdes qu'il y avait au début de la method apply
- Modifié le script damagingeffect.js pour que ca frappe le target au lieu du caster
- Modifié le EffectsPlugin.Application.apply. DAMAGING_EFFET (96-100) 
	-> Ajouté envoie de packet As au target (si cest un gperso) qui a été frappé après avoir exécuté le script.
- Les SORTS de base sont FONCTIONNELS. Jcapable ex. dlancer ronce, grisse joueuse sans bug:  (pe GA300spellID;cellID)
	- Zones fonctionnelles : Manque juste la zone de Cercle à coder dans PathUtils 
		- et vérifier l'ordre des cellules affectées par le geffect 
		- et faire que plus un targetCharacter est loin de la targetCell, moins ca le tape fort) 
	- Vérification des PA faite
	- 
- Ajouté commande LearnSpell	
""
Concernant les sorts de zone:
Une réduction des dégâts se fait sentir sur l'extrémité de la zone, afin d'équilibrer un peu la puissance de ces sorts.
Les valeurs sont simples : 110% au centre, -10% par case d'éloignement. Les cases intermédiaires ont une valeur entre ces bornes dépendant de l'éloignement du centre de la zone visée. A noter que cette variation n'affecte que les dégâts, les sorts ayant un effet de zone, comme Tir Eloigné et Œil de taupe, possèdent la même efficacité dans toute la zone .
De plus, les cibles d’un sort de zone sont désormais affectées toujours dans le même ordre : ce sont les cibles les plus proches de la cellule où a été lancé le sort qui sont affectées en premiers. Pour les cibles qui sont à la même distance, l’illustration suivante permet de connaitre l’ordre exact de détermination des cibles, soit dans le sens des aiguilles d'une horloge :
"""



0.0.60 [28 Mars 2013]
- [TODO] Continuer le Moar.applySpell : 
	- conditions pour lancer un sort, 
	- CC/EC (surtout les armes), 
	- sorts boostés par les panos de classe, 
	- Renvoie du packet GA300xx pour que le client renvoi le GKK et qu'on puisse enlever l'action de la liste d'actions du perso.
- [TODO] Continuer les anciens todo comme :
	- [TODO] Parsing des mapData des Maps et Moar.applySpell
	- [TODO] Commencé methods Map.isCellWalkable et .isCellLineOfSightRequired		
	- [TODO] Moar.applySpell : arme/s.getZoneType() -> getTargets()
	- [TODO] Moar.applySpell : if(cc && arme) -> boost damages  [FAIT]
	- [TODO] Faudra modifier le client à fond pour implanter ça (new zoneType) de son côté aussi pour l'affichage U_U
	- [TODO] Continuer les methods de reloading des tables bdd gworld dans BDDWorldTemplate
	- [TODO] Faire un champs config les pubs automatiques : (sont dans GServ.start en ce moment) 
	- [TODO] Créer la method gclient/lclient .ban();
	- [TODO] À Corriger le reloading des objets ActionsListeners instanciés lorsqu'on reload l'ActionsPlugin
	- [TODO] Réduire le temps de chargement de la GConfig
- Modifié les GEffects des ItemSets, ce sont maintenant des Jet au lieu des Dice
- Corrigé les items suivants qui donnent mtn de la vitalite au lieu de la vie: Boufbottes, Anneau de Bouze le Clerc, Cape Bouffante
- Modifié les GEffects: mit des Jet au lieux des Dice lorsque c'est un jet fixe (+X) au lieu d'un jet aléatoire(+X à Y)
	- Donc mtn des .getJet.getValue au lieu de .getDice.getBaseBoost dans :
		- GStatistiques.boostEquipmentStats, updateEquipmentStats
		- Ginventory.getTotalBonusPods
		- EffectsShare.getSimilarEffect
- Corrigé le GHandler.exceptionCaught, on log maintenant le bon chemin d'exception (StackTrace) avec Exceptions.write
	- Donc enlevé le trowable.printStackTrace qui est mtn inutile :)
- Ajouté variable normalExceptionNode dans Exceptions
	- Modifié method write pour que si le rootNode.getChild(exceptionName) retourné = null, bah on log dans le normalExceptionNode
- Créé plugin FormulingPlugin contenant les formules (Formulas)
- Créé classe AbstractFormuling dans Plugins.Abstractions
- Créé classe FormulingManager dans Plugins.Managers
- Créé classes abstraites dans AbstractFormuling:  AbstractPath, AbstractFormulas, AbstractNode
- Modifié toutes les références à Path et Node dans Syn et les autres plugins.
- Modifié à fond les classes Path et Node qui sont mtn dans le FormulingPlugin et qui extends AbstractPath/AbstractNode
- Récupéré plein d'infos (de pages internets) dans un dossier "infos sur dofus"
	- Contient toutes les classses
	- Tous les items (équipements, armes, outils...ha mais pas ressources)
	- Quelques dossiers divers en plus.
- Ajouté method copy dans GEFffect 




0.0.61 [30 Mars 2013]
- Ajouté champs WeaponDamageMultiplicators dans table de classes 
	- (Ce sont les multiplicateurs de dommage de base des armes pour chaque classe (les 90,95,100% à lutilisation))
- Ajouté method setWeaponDamageMultiplicators dans Classe.java
- Ajouté method calculateDamageOnTargetByWeapon dans FormulingPlugin.Formulas




0.0.62 [2 Avril 2013]
- Créé plugin PluginSystems pour contenir plein de systèmes comme les PvPChannels, le Kolizeum, les DailyChallenges, etc.
- Renommé tous les plugins: Au lieu d'être XXXPlugin, c'est mtn PluginXXX pour pouvoir les distinguer facilement des autres projets dans le workspace, sinon ca devenait bordélique. 
- Commencé les PvpChannels (Classes dans ActionsPlugin en attendant: Channel, ChannelsManager, ChannelEnums)
	- Les ChannelEnums sont : State, FightType, RoundType et LootType
- Ajouté 4 états dans Enums.PlayerState: InPvpChannelPreparing, InPvpChannelReady, InPvpChannelCombating, InPvpChannelLooting
- Créé enum FightType dans Enums avec y comprit le type pour PvPChannel(101)
- Ajouté methods addState(PlayerState), removeState(PlayerState) et setStates(PlayerStates[]) dans ICharacter
	- + Implémenté dans GPerso et les autres. (Rempli le code seulement dans GPerso)
- Ajouté et commencé plein de methods dans Channel.java	
	- toString
	- launchRound & canLaunchRound
	- join & canJoin
	- quit
	- modifyParam
- Commencé method calculateResistances dans Formulas
	- [TODO]: Associer les bonnes résistances quand on a une frappe neutre, 
		- l'effet dans l'enum renvoie à la carac de force vu que quand on tape en neutre, c'est avec la force.
		- Mais quand on résiste, c'est avec les résists neutres.
- [TODO]: J'sais pas si faut que j'mettre une ArrayList de GBuff sur le perso ou pas :S [FAIT]
	- Vu que leurs effets sont souvent (juste lorsqu'ils ont une carac correspondante)
	- compilés dans les GStatistiques dans la colonne de BOOSTs
- Ajouté method isNeutralAttack dans IEffectType et implémenté dans: pour savoir si un effet de dom est neutre
	- PluginEffects.SpellEffectType,DamagingEffect,HealingEffect.
	- C'est juste: return (this == STEAL_X_PDV_NEUTRAL || this == DAMAGE_X_NEUTRAL) 
- Continué les formules de dommages/résistances dans Formulas
- [TODO] Faire un parseur des packets pour les PvpChannels
- [TODO] Établir un ChannelsManager par GServeur au lancement de ces derniers 
	- et garder les objets sur l'emu au lieu de sur le plugin 
		- pour pas avoir des prob de perte de données quand on reload le plugin par après. Sinon externalizer (autre methode de sérialization optimisée)
	- et Faire une interface ou abstraction sur l'emu pour le supporter.



0.0.63 [3 Avril 2013]
- [TODO] continuer les sorts de zone en cercle et les autres todos cités dans la 0.0.60.
- Ajouté method getWeaponDamageMultiplicator(itemType) dans Classe
- Ajouté method calculateDamageOnTargetBySpell dans Formulas
- Ajouté brokle et poisse dans les calculs de dommages 
- Ajouté method hasBrokle et hasPoisse dans EffectsManager et l'abstraction et l'Application
- Ajouté arrayList<GBuff> buffs dans GPersonnage
- Ajouté methods getBuffs, getBuff(effectID), addBuff, removeBuff, setBuffs dans ICharacter 
	+ implémenté dans GPerso
- Formules de calcul de dommages pas mal finies. Après c'est les trucs comme le heal, retrait de pa/pm, ...
- Corrigé une petite erreur dans les calculs: maintenant je mets des Math.max(0, carac) 
	- sur les valeurs carac/intel/dom%/dom pour ne pas prendre en compte les caractéristiques négatives
- Changé les GPersonnage caster pour des ICharacter dans les paramètres des dernières formules de calcul
-  Ajouté method calculateHeal dans Formulas
- Changé le EffectsManager.applyEffect de (ICharacter caster, GEffect e, ISprite target, int mapTarget, GFight f)
	- à (GEffect e, ICharacter caster, ISprite target, Object... other)
- Updaté les références à EffectsManager.applyEffect  (dans ObjectsParser + ConfigurationObj.Command)
	- + Modifié le actionPerformed.actionPerformed pour conformer à ca.
- Exclu le package Pathfinding de l'emu Syn pour utiliser celui dans le PluginFormuling
- Créé classe AbstractPathUtils pour mettre touts les methods de PathUtils en abstrait
- Ajouté la création d'un objet PathUtils dans le FormulingPlugin.FormulingMain.
	 + FormulingManager.setPathUtils(pu);
- Avancé le Moar.applySpell
- Delete method Moad.applyWeapon.
- Ajouté method Formulas.calculateCoupCritique(int tauxCCBase, GStats) (Vrai formule d'officiel prise du client)
- Ajouté method Formulas.calculateEchecCritique(int tauxECBase, GStats) 
- Ajouté l'application des effets pour poisse et brokle dans le même case
	- donc mit le case MINIMISE_EFFET_ALEATOIRE
	- et case MAXIMISE_EFFET_ALEATOIRE
	- Ce sera d'ailleurs le même case pour la plupart des Buffs
- Ajouté l'application pour les DamagingEffects, les HealingEffects et les Renvois
- Ajouté l'effet NO_EFFECT(-1), dans SpellEffectType qui 
	- me permet de skipper le switch jusq'en bas (dans EffectsPlugin.Application)
- [TODO] Coder les effets dans EffectsPlugin.Application :
	- séparer les sorts des armes avec l'avant dernier param:objs[x]=arme|sort et dernier:obj[x]=boolCC
	- utiliser les formules
	- appliquer des buffs + les ajouter à la liste de buff du perso.
	- ajouter les effets manquants
	- Ajouter les packets pour les DamagingEffects 
	//TODO Buffs prenant effet seulement à chaque débuts de tours
	//TODO Buffs prenant effet seulement à chaque fins de tours



0.0.64 [4 Avril 2013]
- Ajouté method calculateDamageOnTargetBySpellWithResists ds Formulas (comme pour les weapons)
- Ajouté method getCooldownEffect à EffectsManager + abstraction + Application
- Créé l'effet COOLDOWN(1003) dans SpellEffectType
- Ajouté le case DAMAGE_REDUCED_OF_X sous la catégorie des buffs de type OneShot
- Modifié l'application des buffs OneShot: 
	- mtn les buffs change leur SpecialArgs pour l'ID du spell si le spell est dans les params de App.applyEffect(,,Object... others).
- Ajouté le fonctionnement des cooldowns quand on lance un sort dans Moar.applySpell
- Ajouté un champs ArmorSpellCharacTypes dans la Config dans la bdd des worlds  et settedup son chargement
	- (Variable = short[][] armorsCharacType)
	- (Y'en faudrait une sur le realm aussi une comme ca pcq là 
    -  c'est bizarre d'aller chercher des données de l'offi dans la Config des gameworlds ;I)
- Modifié la formule calculateResistance pour les armures élémentaires en buff (comme Armure féca genre)
	- Il va chercher dans tous les buffs du target, check si y'a des buffs d'armure élémentaire,
		- prend le SpellID qui a appliqué ce buff dans ses specialArgs, 
		- prend la characteristicType correspondante avec server.Config.getArmorSpellCharacType
		- et voilà il a le nécessaire pour calculer la réduction.
- Créé classe pack.SystemMain à SystemsPlugin + Ajouté le plugin dans la PluginConfig
- Créé commande DEBUFF dans ConsolePlugin pour se debuffer soi-même. 
	- j'ai pas mit de param pour debuff les autres, mais si tu veux tu peux :P
- Corrigé method PathUtils.getCellIDinOrientation pour le SOUTH et NORTH qui donnaient des cell incohérentes
- Ajouté array[] d'Orientation orientationsForCircleZone dans l'enum Orientation. 
	- C'vrm utile uniquement pour la zone de cercle dans les effets.
- Ajouté les Zones d'effets en Cercle dans PathUtils.getTargetsInAreaString
- En gros dernièrement:
	Sorts de zones terminés (il me manquait la zone de cercle dont j'viens de finir de créer l'algorithme).
	Armures terminées.
	Résistances terminées.
	Effets de dommages terminés (Y comprit avec les bonus CC, maîtrises et cie...)
	Effets de heals terminés.
	Effet de renvois de dom terminé.
	Buffs terminés (Avec Brokle et Poisse en prime en plus des armures)
	Cooldowns terminés.
	Probabilités de réussite de lancement du sort terminées (Ex. Roulette)
	Lancers en ligne, lancers sur cellule libre, états requits/interdits, min/max de PO, CC/EC  terminés.
- Corrigé un nullPointerException dans LAccount.terminate grâce à: if(this.gift != null) this.gift.terminate();
- Modifié la commande 'load' dans le Console plugin pour faire (ex) "load table:items" au lieu de "load gitems".
	- + Corrigé un bug sur le for() qui parsait les params, fallait maitre i >= 0 au lieu de i > 0;
- Corrigé EffectsManager.getHealingEffect qui renvoyait un aepl.getDamagingEffect au lieu de aepl.getHealingEffect
- Mit le timer de pubs à 10minutes, faudrait toujours le mettre en config ces pubs là ...



0.0.65 [5 Avril 2013]
- Corrigé un bug sur les commandes qui n'avaient aucune conditions en ajoutant if(conditions.length() > 0 && Condition.parse..
- Amélioré l'exception catcher dans GHandler avec if(s.toString().contains("org.apache.mina") == false){
	- Pour ne pas afficher les messages inutiles d'apache mina lorsqu'une exception est levée
- Corrigé un bug de parsingInt("") dans LAccount.<init> l.60 en mettant
	- if(friendsIDs != null && friendsIDs.length > 0 && friendsIDs[0].length() > 0){
- 	
   Cherche comment afficher les animations des sorts ig .. ;o  [FAIT]


0.0.66 [7 Mars 2013]
- Rechangé la lecture des GConfig au démarrage en STaX au lieu de JDOM, beaucoup plus rapide.
- Ajouté method loadPlugins(Strinf pluginConfigName) dans Plugins au lieu d'avoir à faire Plugins.getLoader.load()
- Mit le call à Plugins.loadPlugins(configName) dans Syn en threadé :)
- Mit le call à SQL.setUpConnexion dans Syn en threadé :)
- Ajouté une variable Future<Object> dans SQL.SQL 
	- pour que le lancement des server/world attende que le setup SQL soit fini avant de starter
- Mtn tout ce qui est callé dans le lancement de syn est threadé :)
- Lancement de Syn mtn possible en 79 ms !! http://snag.gy/C0k31.jpg
- Ajouté method purgeCancelledThreads dans ThreadsManager
- Commencé à analyser dans le client dofus.blabla.GameActions le processing de l'action 300 lancer de sort
	- [TODO] Faut ajouter une variable/colonneSQL pour : displayType, spriteAnimation, showInFrontOfSprite.
	- Commencé le packet d'Action pour les sorts dans ActionPlugins.App.case SORT (pour l'affichage du sprite, message et tout)
	-  |- [FAIT]


0.0.67 [8-9 Mars 2013]
- Ajouté commande TERMINATE_PERSO_CLIENT dans ConsoleListener pour terminate un GClient(+perso/compte) à partir d'un persoID
- Enlevé quelques constantes de la classe Syn, mises dans Constants et commentées vu quelles étaient inutiles
- Changé le maximum des actionsID dans GWorld.getNextActionID à 10000 au lieu de Integer.MAX_VALUE
	- Le 10 000 vient du client dans ank.utils.Sequencer.getActionIndex(), il fait pareil.
- Modifié la structure table spells, ajouté colonnes: spellSprite,characterSprite,displayType,showInFrontOfSprite et delete: sprite,spriteinfos
- Ajouté method SQL.Spells.updateAllSpellAnimationsParameters dans Spells pour la nouvelle structure de la table de spells
	- Updaté les données de la table de spells
- Modifié SQL.Spells.load et loadAll pour la new structure table spells
- Ajouté method getLevel dans GSpell
- Ajouté packet GA_MAP dans ActionsPlugin.App.case SORT -> affichage animations parfait + message aussi ("Truc a lancé armure moche")
- Ajouté la table de spells à la liste de tables des worlds. 
- Ajouté la method de chargement de tous les spells dans le BDDWorldTemplate pour quand on veut reload
- [TODO] Corriger les spellsLists de départ avec la classes_config   [FAIT]
	- Corriger le packet de spellList pour ne pas afficher deux fois le même sort IG 
		- (Quand on apprend un sort > notre niveau et ensuite monte de niveau, tu lapprend en double jpense)
	- Corriger le level up  (+ intégrer les variables des classes làdedans comme statsPerLevel)


0.0.68 [10 Mars 2013]
- Corrigé les sorts de départs des classes de base (classes_config)
- Ajouté method Classe.getSpellLearningAtLevel
- Corrigé la commande de levelup pour prendre compte de: gainedStatsPerLevel et spellLearningAtLevel
- Corrigé ActionsPlugin.App.applyOnDone avec:
	- bolean removeSuccess = p.getActions().remove(a);  Ensuite y'a le switch-case.case MOVEMENT
	- 	et le case.DEFAULT:  qui fais mtn: return removeSuccess; au lieu de return false;
- [BUG]
	11 avr. 2013 00:41:25 Handlers.GHandler messageReceived
	GRAVE: GHandler essaye de supprimer un perso alors qu'il est connecté   [CORRIGÉ]


0.0.69 [11 Avril 2013]
- Modifié le GClient.kick, le currentPerso est maintenant retiré du world (mais gardé dans l'compte)
	- pour pouvoir faire l'action de supprimer le perso après. 
	- (Avant on pouvait pas l'delete, il était encore "connecté" vu quil était dans le monde)
- Modifié la suppresion de perso, ajouté p.getAccount().setCurPerso(Constants.ZERO_BYTE); au début.
- 


0.0.70 [12 Avril 2013]
- Créé interface Injectable dans src.Interfaces
- Créé DataPlugin pour overrider les enums et les constantes de l'emu
	- Créé interface Injector
	- Créé enum CharacterTypeInj
	- Explication: Implémente toute les enums de l'emu avec Injectable
		- Ensuite tu peux recopier les enums de l'emu dans le plugin 
		- Implémenter Injector dans ces enums copiées auxquels on ajoute le sufixe 'Inj' comme on ajouterait 'Impl' à une implémentation.
		- Ensuite ajoute cette enumcopiée-injector dans la liste d'injectors dans le main
		- Et voilà dès que le plugin sera activé, 
			- il overridera toutes le valeurs des enums de l'emu par les enums du plugin.
- [TODO] Google Guice -> injecte du code pour overrider les classes-objets et absolument tout.
	- En plus ca sera beaucoup mieux que mon truc d'injectable/injectors :3 [En fait non, c'dla merde, tu peux pas reload guice at runtime]

- [TODO] Maitrises d'armes comme dans disgaea:
	- On met des nouveaux characteristicType du genre XP_MAITRISE_ÉPÉE
	-   et on stock l'xp accumulée là dedans.
	- Plus le niveau de la maitrise monte, plus c'est dur de l'XP (logique)
	- Les monstres plus forts donnent plus d'xp/par coup.
	- Dans le fond c'est de la meme manière que l'XP des personnages, 
		faut faire une nouvelle colonne d'xp pour les maitrises
	- N'oublie pas de mettre ce feature désactivable pour les ankalike qui veulent garder maitrise officielles
	- IG on affichera une nouvelle barre d'XP de maitrise proche de celle du perso et d'l'énergie
		- Avec le % dessus ainsi que le Niveau à coté et l'icone représentant le type d'arme.
	- Et tu rajoutera un packet à la connexion si on a une arme + quand on change d'arme.	
		- (Pour dire au client combien d'xp le gars a dans cette maitrise pour quil l'affiche)
	:D
- Ajouté method getWeaponMaitriseType dans CItems pour avoir la characType de maitrise associée au type d'arme



0.0.71 [14 Avril 2013]
- Ajouté un packetCantParse dans AccountParser quand on essaie de boost stat sans avoir assez de points
- Trouvé une pas pire formule pour l'xp des maîtrises: xp = (lvl^2 + 6*lvl + 9) / 0,09
- [TODO] [FINI 19juillet] Commencé les modifications client pour Syn (Affichage de la barre d'xp de maîtrise) 
- Ajouté method calculateMaitriseLevel dans Formulas + dans le manager et l'abstraction


0.0.72 [15 Avril 2013]
- Modifié les variables des GPersonnage: le Level est mtn stocké dans les GStats
- Commencé les combats:
	- Changé les arrayList fightersBlue/Red par ArrayList<ArrayList<ICharacter>> teams = new...
	- Ajouté method organizeTimeLine dans GFight
	- Ajouté une variable ArrayList<ICharacter> timeLine 
	- Ajouté methods start/end Round/Turn dans GFight
	- Ajouté methods apply+debuff dans GBuff
	- Ajouté method getCurrentFighter dans GFight
	- [TODO] Faire le packet GM des monstres et des groupes de monstres
	- [TODO] Faire les incarnations !
	- [TODO] Faire les deux effets d'invocations 
- Ajouté variable oppositeEffect dans l'enum de SpellEffectType 
- Ajouté method getOppositeEffect dans SpellEffectType et l'interface IEffectType
- [TODO] Commencé les case manquant dans ParsingPlugin.GameParser
	- [TODO] Commencé method onGameTurnEnd dans GameParser
	- [TODO] Commencé method onGameReady dans GameParser 
- Ajout de la PiouLib pour le scripting: JavaScript, JRuby, Jhyton, Groovy, Lua, Java...
- Ajouté method invoke à l'interface PiouLib.Intepreter et implémenté dans JavaScriptInterpreter pour call des methods précises
- Refonte de l'effet EXE_JAVASCRIPT(1001) dans EffectsPlugin.Application
	- Le specialArg de l'effet doit mtn être: scriptName.methodName@boolReEval
- 
[TODO] Trouver les packets de combats/buffs etc ! :D
[TODO] Mettre le SM dans le ParsingPlugin ? Un peu dur pour les perfs et la facilité d'usage :s 
	- pourait pu faire simplement SM.Accounts.Af   p.ex...
	- Sauf si on le fait avec Guice peut-être ? :O




0.0.73 [16 Avril 2013]
- [TODO] Finir le packet GM des GPersonnage  (Method getSpritePacket)
- [TODO] Finir le packet GM des monstres
- [TODO] Faire une method pour connaître l'ID de la team d'un joueur en combat
- Créé classe GDrop
- Créé classe GInvocation
- GROSSE REFONTE DE FOU DES CHARACTERS
- Créé package Abstractions
- Créé classe abstraite CombativeCharacter implements ICharacter
- Mit GMonster et GPersonnage en extends CombativeCharacter au lieu de implements ICharacter
- Créé classe abstraite AbstractCharacter
- CombativeCharacter extends AbstractCharacter au lieu de  implements ICharacter
- Ajouté method getNextCharacterID dans GWorld
- Ajouté method getMonsterTemplate et getMonsterInstance dans GlobalWorld
- Ajouté HashMap<Short, GMonster[]> monsterTemplates dans LWorld et GWorld
	- Ajouté methods set/get/add/remove MonsterTemplate(s)
- Ajouté constante minimumIDinWorldMonstersTable = 5000 dans CServers
- Ajouté method setID et setServer dans IObject
- Créé classe Monsters dans SQL
- Modifié le GStats.getPA/getPM pour accepter un paramettre Classe null
- [TODO] Enlever toutes les variables mtn inutiles dans les array[] dans GPersonnage
- Delete plein de methods de dans ICharacter et laissées dans CombativeCharacter
	- + Ajouté get/setLevel et getStatistiques en abstract dans CombativeCharacter 
- Updaté toutes les erreurs/références à ce qui a été modifié dans l'emu et les plugins 
- Créé classe EffectApplicationParameters dans la UtilsLib pour holder des paramètres plus facilement
- Changé     EffectsPlugin.apply(GEffect e, ICharacter caster, ISprite target, Objet... other
	    pour EffectsPlugin.apply(GEffect e, CombativeCharacter caster, AbstractCharacter target, EffectApplicationParameters eap
	    + Modifié le EffectsManager pour ceci et ObjectsParser et plein de marde.
- [TODO] Commencé tables monsters, monsters_groups dans bdd Syn
	- et les mêmes + monsters_instances, monsters_groups_instances dans world
- [TODO]  Est-ce que je fais une table de drops ou pas ???  
	- Pcq certains drops ont un taux différent dépendant du monstre sur lequel ils sont...
- Créé classe GMonsterGroup
- Ajouté fightType MVM(101) //Monsters Versus Monsters
- Ajouté method setFightMapToCombatters dans GFight
- Continué un peu les GFight.createNew
- Ajouté method copy dans GStatistiques et GMonster
- Ajouté method copy dans CombativeCharacter et AbstractCharacter (utilise notamment des super.copy())
- Ajouté une ptite method getStatistiquesID dans GMonster


- [TODO] ASSERT de maths pour être sûr que le résultat d'une opération mathématique de donne pas d'OverflowException
	-> Exemple dans un int i = a+b;  ça vérifie que a+b soit <= Integer.MAX_INT;  Des trucs comme ça pour protéger.
	- https://www.securecoding.cert.org/confluence/display/seccode/INT32-C.%2BEnsure%2Bthat%2Boperations%2Bon%2Bsigned%2Bintegers%2Bdo%2Bnot%2Bresult%2Bin%2Boverflow




0.0.74 [19 Avril 2013]
- Modifié le EffectParameterApplication:
	- Rename en ParameterHolder
	- Change l'Object objet en Object condition
	-> corrigé les problèmes d'actionListeners like a boss
- [TODO] Monstres: bdd, loading, stocking world, ...
- Travaillé sur le client. Nouveau système de modules.
- TOOD: Interactions: AbstractCharacter.getInteraction()	
	- interaction().getNPC() -> dialogue, échanges, vente.. avec un pnj,
	- interaction().getExchange() -> échange avec un pnj, joueur, banque, taxCollecter etc.
	- interaction().getIO() -> objets interactifs (ateliers métiers, objets élevage, livre métiers, etc)
- Ajouté les terminate dans AbstractCharacter, CombativeCharacter, GmonsterGroup, GMonster, GDrop
- Reformé la method de chargement des monstres
- Complété methods set/get Level dans GMonster
- Ajouté boolean isInstance dans GMonsterGroup
- Ajouté method saveInstance dans SQL.Monsters
- Ajouté method getMonstersInstancesIDs dans GMonsterGroup



0.0.75 [22 Avril 2013]
- Fait un jeu avec le prinny.
- Créé classe abstraite Interaction
- Créé classes NPCInteraction, IOInteraction, ExchangeInteraction dans le PluginSystems
- Créé interface IInteractionType
- Créé enum InteracionEnum implements IInteractionType
- ExchangeType implements mtn IInteractionType
- [TODO] MONSTRES , ACTIONLISTENERS 


0.0.76 [23 Avril 2013]
- Travaillé sur le client, presque fini d'ajouter la barre d'xp de maitrise.


0.0.77 [24 Avril 2013]
- Delete la table actions_listeners
- Créé la table actions_listeners_world
- Créé la table actions_listeners_maps
- Créé la table actions_listeners_npcs
- Créé classe SQL.ActionsListeners
- [TODO] Continuer la refonte du chargement et du management des actionslisteners
- [TODO] Mettre les LServer en objet, un par créateur de serveur utilisant mon emu. 
	- ainsi que mettre une table d'accounts/config/gifts par créateur de serveur.
	- ce qui lui permet d'avoir sa propre table qu'il peut mtn gérer lui-même. (et c'plus clean qu'avoir tous les serveurs dans une table) 
	- permet de chosir les gameservers ouverts sur son login.
	- En bref: Arraylist de lserv, Arraylist de gserv: un login par créateur; plusieurs games par logins.
	- config toujours propre à chacun
	- Une BDD par login et par game (pour chq créateur) + une bdd générale pour les données de l'officiel

- Créé classe SQL.Npcs
- Ajouté method getActionsListenersIDs dans SQL.Npcs et SQL.Maps
- Ajouté l'arraylist d'actionlisteners dans GNpc comme y'avait dans Map, avec les methods
- Complété la classe SQL.ActionsListeners pour les chargements
- Modifié la method SQl.Maps.load pour setter les actionslisteners de la map.
- Fini le packet GM des monstres : 
	- [TODO] manque juste le paramètre isNoFlip que j'connais pas.
- Ajouté method getCharacterTeamID dans GFight	
- [TODO] Caller le chargement des monstres et les ajouter sur la map.
- [TODO] Un générateur de macros pour les PNJs, Monstres, IA:
	- Le tool a un bouton Start/Pause/Stop recording macro
	- Quand on lance le recording, il enregistre chaque clic, action, interaction, etc faite dans dofus.
	- Il créé ensuite un fichier décrivant celà qui sera utilisable par un PNJ, un monstre, une ia ...
	- C'est en fait en quelque sorte une intelligence artificiel en soi-même,
		- Ça donne une suite d'actions à faire et le pnj/monstre les exécutes.
		- On peut ainsi générer un parcours fait par le character avec des dialogues, lancement de combat,
		 	- utilisation de commandes GM comme se téléporter et téléporter un joueur
		 	- donner un item en mode auto, en échange, en jeté parterre...
	- Le tool comprime cette suite d'actions en un script assez simple à lire et exécuter et voilà,
		- on a notre pnj vivant ou notre groupe de monstre migrateur, etc.
- Commencé le système de macros et de recording dans le PluginSystems
- Dans PluginSystems: créé package MacroScripting
	- Créé classe Language
	- Créé classe Macro
	- Créé classe Recorder
	- Créé classe Directive
	- Ajouté plein de directives type comme créer une varable :) 
- Créé un dossier "macros" dans Syn_scripts et créé mon premier macro :)
- Créé aspect MacroRecorder dans AspectJPlugin :3
- Ajouté method getInteraction à AbstractCharacter	
- Ajouté method parsePathFromTwoNodes dans PathUtils
- Updaté la liste de tables du game dans BDDWorldTemplate



0.0.78 [25 Avril 2013]
- Corrigé le GHandler.exceptionCaught en rajoutant le nom de l'exception levée avec:
	- Exceptions.write(arg1.getClass().getName(), stackTrace);
- Continué les macrosScripting 
- Refonte des variables de personnages: presque pu rien dans les array
- Delete le parametre lvl dans initGPerso
- Complètement refonte du GPerso.createNew
- Ajouté le level du perso dans la table characteristic_base
- Delete la colonne level de la table persos
- Ajouté le setting du level du perso dans GStats.createNew() en fonction du startLvl de sa classe
- Mit le chargement des stats dans le SQL.Personnages.loadServerPersoList
	- loadStatistiquesBase(p);,  drete avec le chargement de leurs inventaires.
- Corrigé le actionPerformed dans ActionListener+Container 
	- par rapport au isCompleted, on pouvait avoir des nullexceptions sur le ParamHolder avant.
- [TODO] Faire les superarea, areas, subareas pour pouvoir gérer les groups de monstres à spawn.
- Travaillé beaucoup sur la structure du chargement et gestion des monstres/groupes de monstres
	-  + les spritepacket GM



0.0.79 [26 Avril 2013]
- Update la liste des tables du login .
- Delete la table monsters_instances
- Ajouter colonne drops dans monsters_groups_instances 
	- [TODO: Ajouter le chargement des drops dans Monsters.loadGroupsInstances] 
- Delete colonne grade et statistiques dans table monsters
- Ajouté colonne level dans table monsters_statistiques
- modifié le chargemant des instances de groupes: 
	- delete method loadInstance dans SQL.Monsters et dans GMonster

- Commencé à créer mon propre language de scripting avec XText pour faire suit aux macros


0.0.80 [28 Avril 2013]
- Continué mon propre language: Créé le projet sous le nom MacroSDK
- Ajouté fonction getMethod dans LibUtils.Codeinput
- Continué le parser/interpreter dans PluginSystems.MacroScripting
- [TODO] Corriger les bugs sur Syn quand on charge des maps, se co, j,sais pas trop, en tk, etc.
- Créé classe Bloc dans MacroScripting
- Refonte du parser dans MacroScripting/Macro
- Ajouté method execute, execute(from/to), execute(ids[]) dans Macro
- [TODO] Créer un bot pour tester Syn, le mettre à l'épreuve: flood et cie comme si tavais vraiment 10000clients
- [TODO] Continuer les monstres avec les areas, spawns, ...
- Modifié le MacroManager pour permettre de lancer un macro
- Fini d'implémenter le keyword GOTO
- Ajouté commande MACRO [characterID] [targetCharacterID] [macroFilePath] -> les ID sont cherchés ds map.
- Les Macros fonctionnent un peu, mais reste des bugs à régler
	- Dans Bloc.preload, il a de la misère avec les blocs multi-directives. -> [CORRIGÉ]
	- Oh et après test, il a de la misère meme avec les multi-blocs à simple-directive. -> [CORRIGÉ]


0.0.81 [29 Avril 2013]
- Corrigé des bugs sur la lecture/parsign/interpreter des macros
- Ajouté le déplacement de personnage aux macros
- [TODO] Tenté de faire fonctionner le recorder en aspectJ sans réussite. [Impossible, aspectJ est static]
- MacroSDK presque terminée, manque just le générator de .micro
	- et quelques checks de validations (comme s'assurer que les Bloc pointés par les GOTO existent bien)
	- et finir le parser pour les nouveaux keywords pas encore gérés.
	- Ajouté keyword WAIT et LOCK
	- Ajouté plein de templates de code dans les préférences du projet de test
	- Refonte un peu
- merde, jai perdu ma derniere version du changelog.
- La MacroSDK est terminée, fonctionnelle.
- Le parser aussi, sauf pour les WAIT et LOCK
	
	
0.0.82 [30 Avril 2013]
- Créé interface IServer extends IObject pour implémenter dans les G/LServer
- Modifié SQL.Maps.load -> Les monstersGroupsInstances chargés sont mtn ajoutés à la liste de sprites dla map
- Modifié tout le chargement des mobs instances/fixes. ça marche presque. manque juste le packet
- Créé 
- Modifié un peu les tables sql pours les monstres. D'ailleurs j'ai rajouté monsters_groups_instances ds le login.
- TODO Régler le bug de code en boucle dans GMonster quand on veut avoir le level du monstre ou son grade.[FAIT]
- Corrigé le GMonster.getStatistiquesID qui utilisait le getID au lieu de getTemplateID
- [TODO] = Continuer/Finir le GM packet des groupes de mobs.  [FAIT]


0.0.83 [1 Mai 2013]
- Fini l'affichage GM des groupes de monstres au complet.
- Commencé les tables areas_super, areas et areas_sub
- Établi la structure pour les spawns "aléatoires": ça fonctionne par subzone:
	- tout mit le systeme sur papier.
- Ajouté short subAreaID dans Map + des fonctions get/set
- Commencé nouvelle classe MGList pour remplacer GMonsterGroup quand j'aurai fini de la coder
- Ajouté des trucs dans GArea.GSubArea: private HashMap<GMonster, Double> spawningMonsters = null;
	- et private short maxMonsterGroupSize = 8;
	- [TODO] À mettre dans une colonne dans les subareas ou dans les maps. +Le maxNumberOfGroups (peut-être)


0.0.84 [2 Mai 2013]
- Créé nouvelle table sql "official_maps_supplementaries" 
	- pour que les serveurs puissent ajouter des trucs aux maps offi sans déranger les autres servs:
		- un serv pourra ainsi avoir le zaap d'astrub completement vide et l'autre avec des marchands shop.
	- [TODO]: Créé une HashMap dans laquelle on preload ces maps supplémentées au lancement du serv.
		- Normalement les gens devraient pas avoir bcp de choses à modifier sur les maps offi 
			- c'surtout juste une ou deux maps shops et une pvp la plupart du temps alors c'correct ;)
- Ajouté method startFight & endFight dans GFight
- Ajouté method loadAllOfficialMapsSupplementaries dans SQL.Maps
- Ajouté ce loading dans le constructeur de GWorld:
	- SQL.Areas.loadAllAreasTypes(this, true);
	- SQL.Maps.loadAllOfficialMapsSupplementaries(this, true);
- [Idée] : On pourrait faire que TOUS les ID >= 15000 sont à charger dans les world et les autres dans l'offi.	
- Créé package de fights dans GameObjects
- Créé classe FightPvm pour extends GFight de manière à c'que tous les types de fights soient séparés 
	- et aillent leur endFight/startFight/constructeur à part
- Ajouté method saveMonsterGroupList
	|-> sauvegarde la liste d'ID d'instances de groupes de monstres ds colonne: monstersGroupsInstances.


0.0.85 [6 Mai 2013]
- Les GMonsterGroups loadés par instances sur les maps sont mtn settés l'ID qu'ils ont en bdd.
	- ID setté dans GMonsterGroup.loadInstance(...);
- On ne peut mtn plus avoir deux GMonsterGroups instances sur une même map avec le même ID
	- dans SQL.Monsters.loadGroupsInstances
- Complété les méthodes de chargement des areas, super, sub.
- Ajouté le chargement direct des allareas dans le LWorld.
- Ajouté les HashMap pour les allareas dans le LWorld + les methods de get/set
- Les officialComplementaryMap ont mtn leur ID en négatif.
- Modifié la method gworld.getMapWithoutAutoLoad pour ajouter un boolean qui controle le 
	- si on tien compte des maps complementaires, overrides des officielles.
	- Donc si on met true, il regarde dabord si l'HashMap contient l'ID en négatif et ensuite celui en positif. 
- Ajouté le chargement des possibleMobs dans les SubAreas
- Ajouté une ArrayList des Areas contenu dans une SuperArea
- Ajouté une ArrayList des subArea contenu dans une Area
- Complètement changé les methods de chargement des super/area/sub
- Ajouté method getFreeCellRandom dans le FormulingPlugin, dans le PathUtils.
- Ajouté des if(lastTrucID == Integer.MAX_VALUE){  lastTrucID = 0;  }
	- Dans tous les GWorld.getNextXxxID();    genre Item, Character et Perso
- Ajouté method attachToMap(Map m) dans GMonsterGroup.
- Corrigé un bug de boucle infinie sur les getLevel quand on faisait Perso.createNew{GStats.new}
- Créé commande RESPAWN pour regénérer des groupes de monstres aléatoires sur la map.
- Modifié le GameObjects.Map.copy() pour bien copier les GMonsterGroup
- [TODO] Transférer les données SQL des tables de monstres d'ancestra à Syn.  [FAIT]



0.0.86 [7-9 Mai 2013]
- Commencé les methods pour transférer les monstres de Zen à Syn dans SQl.Monsters
- Créé l'interface Executable implémentée par GEffect, GAction et par PluginSystems.IA.Network
- Commencé un premier test de structure d'IA neuronale/adaptive avec une implémentation des concepts de l'électricité
	- Créé package IA dans PluginSystems
	- Créé classes ElectricalFlow, Network, Neuron dans IA.
- http://www.heatonresearch.com/online/introduction-neural-networks-java-edition-2/chapter-1/page4.html
- Commencé pas mal de recherches sur l'IA neuronale 
- Ajouté classe NeuronContainer
- Fait plein de tests, essais, lecture, documentation sur les IA neuronales.
- Commencé à convertir pour Syn l'IAModel + ses implémentations que j'avais créé sur Zen, 
	- on pourrait s'en servir comme début.
- Ajouté colonne kamas et sagesse dans monsters_statistiques dans bdd login
- Ajouté colonne xp dans monsters dans bdd login
- Finit le transfert de smobs de zen à syn.  (corrigé plein de bugs sur mes methods pour pouvoir transférer._.)
	- ( [TODO] manque d'ajouter les possibleMobs aux sub_areas...)




0.0.87 [12 Mai 2013]
- Commencé respawn en fin de combat ( Fightpvm.endFight)
- Modifié GFight.newPVM
- Transféré les monstres + drops comprits
- Commencé à transférer les mobGroupsFix dans monsters_groups_instances
	- method SQL.monsters.transferMonsterGroupsFromZen
	- Ajouté colonne Stars et Type à monsters_groups_instances
		| - Modifié le query d'insertion de GMonsterGroup
		| - Modifié le query de chargement de GMonsterGroup
	- Ajouté objet GFight dans GMonsterGroup pour pouvoir le respawn quand le combat est fini et qu'ils ont gagnés (ou qu'ils sont static)
	- Créé enum MonsterGroupType dans GMonsterGroup	
		- SUBAREA_GENERATED
		- HEROIC_INSTANCE
		- STATIC_INSTANCE
- [TODO] finir transferts monstres/areas 
	- et on pourra commencer les lancements de combats + reconnexion en combat	
	


0.0.88 [13 Mai 2013]
- Continué le FightPvm.endFight
	-  Réussi à déterminer quel MonsterGroup de la map a gagné ou perdu, manque de leur donner les drops de joueurs.
- fait plein daffaire
- Ajouté commande RESPAWN



0.0.89 [14 Mai 2013]
- Trouvé deux nouvelles Conditions: "BE" et "AA" (BasicEpisode et ...)
- Retransféré les monstres
- Finit de transférer les groupes de monstres dans monsters_groups_instances.
- Finit d'ajouter les groupes de monstres statiques aux maps correspondantes.
- Modifié le parser loader de monstres pour accepter quand les colonne de spells+drops contiennent juste un grade..
- Trouvé à quoi servait le parametre "ep" dans les lignes des langs:
	- Le client vérifie si ce "ep" est plus ou moins grand que:
		-  this.api.datacenter.Basics.aks_current_regional_version
	- Et si le ep est plus grand, alors il fait comme si l'item, la map, etc n'existait pas.
- La condition "BE" sers à la même chose.
- Le paramètre "p" dans les maps est expliqué là:
	- p: [[[1029, 1030], 23, "BE>15"] 
		= [ objetsTilesID, cellID, condition ]
- Tout ça sert à faire des "épisodes" ou "versions" du jeu.
	- Tu peux donc avoir une version avec seulement 2-3 maps et une autre plus avancée avec 1000 maps par exemple.
	- Le condition "BE" peut même servir à afficher/cacher des cells dans les maps
	- Exemple: 
	MA.m[4721] = {x: -25, y: 28, sa: 72, p: [[[1029, 1030], 23, "BE>15"], [[1029, 1030], 231, "BE>15"]], ep: 14};
	- D'abord, le ep minimum est de 14 pour afficher la map.
	- Ensuite, sur les cellules 23 et 231, si la condition BE return false, 
		- alors les Objets 1029 et 1030 seront cachés sur la cellule 23 et 231 (ils ont les mêmes objets).
			- (Par objets j'parle de genre: ground layer0, objet layer1, objet layer2..)
			

0.0.90 [15 Mai 2013]
- Corrigé GArea.generatedRandomMonsterGroup en mettant : if(spawningMonsters == null){ return null; }
- Corrigé tous les querys de save/update/create des personnages et stats de perso
	- en bougeant le field 'level' dans les stats au lieu de al save du perso luimeme.
- Corrigé un bug dans MacroManager, il inversait le target et character
- Passé l'objet de GStatistiques des GMonsters directement dans la classe de monstre à la place de dans les worlds
	- Plus simple, moins consommant en ram, 
	- Juste remodifié les fonctions de getset des stats et de chargement des monstres.
- Modifié le AbstractCharacter.copy pour que ça fonctionne avec tous lestypes de character-
- Delete la method AbstractCharacter.copyAsMonsterGroup devenue useless
- Créé la classe MapLayer
- Eufff bah énormément de travail dans le GFight.createPVM
	- + dans les packets Game.GM_ADD, .GM_MODIFY, .GM_ADD_TO_MAP, .GM_REMOVE, .showAllSprites();
- [TODO] Refaire le fight.organizeTimeLine, il fait tout buger, la timeline est remplie par un seul et même character  [FAIT]
- TimeLine corrigée
- Testé quelques packets d'affichage comme GS et GTL, c'est nice
- [TODO] refaire toutes les méthodes d'affichages de GM, 
	- tout ce qui a un lien avec l'envoie de packets à la map ou à la fight. 
	- tout c'qui a rapport à la liste de sprites
	- Donc chat.cmk, emote, attitude, GM_ADD, GM_MODIFY, GM_REMOVE, showAllSprites, char.onAddedToMap etc.    t__t
	- il faut le faire avec les layers.
- [TODO] Faire la reconnection en combat dès que t'auras fini l'affichage primaire
- Travaillé sur les macros, particulièrement le MOVEMENT pour essayer de faire bouger des monstergroup et personnages
- Découvert la librarie Transform qui permet d'ouvrir + modifier ou créer des swf de n'importe quelle version en as1
	- J'ai fait des tests dans la workspace Tool
- Supprimé l'override du getFight dans GPersonnage
- Mit les ID de MonsterGroup en négatif vu que c'est des characters et non des personnages 
	| -> GMonsterGroup.loadInstance : mg.setID(-groupID);
	- [TODO] faier que le GWorld.getNextCharacterID ne génère pas d'ID interférant avec ceux des instances statiques.
	- Faudrait donc que le GWorld.getNextCharacterID commence à un certain point, 
		- metons 10 000, qui serait l'ID maximum des instances et minimum des nouveaux characters générés.
- [BUG] Gros problème quand on fait l'affichage du combat au joueur, son .getFight est null alors ca bug.
- Corrigé ce bug de fight nulle ^
- Delete l'interface ICharacter, transféré les methods qu'il avait jusque dans AbstractCharacter
- Instauré les layers:
	- Ajouté champ byte layer = 0; dans AbstractCharacter et dans Map
	- Ajouté method get/set Layer dans ISPrite, implémenté dans AbstractCharacter
	- Ajouté method getNextLayer dans Map
	- ReModifié les  Game.GM_ADD, .GM_MODIFY, .GM_ADD_TO_MAP, .GM_REMOVE, .showAllSprites();
- L'affichage se fait maintenant parfaitement entre les sprites en combat et ceux qui ne le sont pas :D


0.0.91 [16 Mai 2013]
- Ajouté commande LAYER [spriteID?] pour savoir le layer d'un sprite sur la map ou du notre qui on met pas d'args.
- [BUG] Quand j'lance un combat avec Eca, Leo reste affiché encore là ainsi que les autres mobgroups
	- Mais ensuite si j'fais setmap 7411 sur Leo, alors il se désaffiche sur Eca.
- Créé un fights.txt dans Syn_data/fonctionnement
	- Il contient tous les packets de lancement de combat et leur explication 
- Créé tables scripts.sql et plugins.sql dans dossier config de la bdd world.
- Créé table gameservers.sql dans bdd login
- Créé un convertisseur de .tgam -> .tga dans le projet Tests, classe tgamConvert
- Commencé à mettre les LoginServer/World en objet 
	- et à transférer plusieurs trucs du lworld au globalworld. 
	- Big travail ;p
	- Rajouté objet LServer dans LAccount.
	- Créé interface IService
	- Créé classe Services


0.0.91.1 [17 Mai 2013]
- Continué le travail sur les LoginServers en objet
- Continué à créer les ToolServer/Client
- Mit le systeme de pub en script .js
	-> Ils ont juste à se servir des threadManager.newscheduleRepeated dans le .js 
		- et l'exécuter au lancement de l'emu.
- Mit la classe SQL en objet, en ai donné un à chaque login, chaque game et 3 de base dans la classe Services
- Delete interface IServer
- Créé source package TCP dans la UtilsLib qui contient des abstraction pour des 
	- MinaServer/Handler
	- NettyServer/Handler
- Commencé à coder des serveurs avec Netty au lieu de apache mina (dans la UtilsLib)
- GServer extends maintenant MineServer
- Refait le lancement de l'emu
- Refait le lancement des loginServers
- Refait le lancement des gameServers
- Refait le lancement des sqlService
- Refait le chargement des plugins
- Refait le chargement des scripts
- Créé classes Scripts et Script dans PiouLib
- Donné un objet Scripts et Plugins à chaque GameServer
- [TODO] Faire le call à Maps.saveMonsterGroupList(null, null); dans SQL.Monsters.saveInstance
- Ajouté un short title aux GPersonnages + dans leur table de bdd
- Delete la classe TitleManager (Exclude en fait)
- Corrigé toutes les erreurs que j'avais générées en recodant l'emu, y comprit dans les plugins.
- FINI LA RESTRUCTURATION



0.0.91.2 [18 Mai 2013]
- Fini la restructuration totale des LServer, GServer, ToolServer, Services, SQL, etc :P
- Commence à refaire le boosting de performances au lancement de l'emu
- Le chargement du GlobalWorld (Plus précisément des 242 sorts de classe de base) prend 1000ms ...
- Ajouté commande RELOADSCRIPT
- Commenté plein de commnades dans le ConsolePlugin, 
- [TODO] Recoder toutes les commandes qui ont été commentés.
- Les plugins et les scripts sont maintenant en bdd
	- Et sont chargeables depuis des url externes 
		- donc on peut héberger nos propres plug/script sur un autre dédié, vps, etc.
- Corrigé un bug à la connexion quand on essayait de se co avec un compte inexistant, y'avait nullPointerException
- Ajouté ceci à la UtilsLib dans TCP, j'utilise le MinaClient/Handler dans mon CTool
	- MinaClient/Handler
	- NettyClient/Handler
- Ajouté les restrictions sur les maxLaunchByTurn et maxLaunchByTurnByTarget des sorts dans l'ActionsPlugins.Moar
- [BUG-TODO] Le rechargement des scripts ne fonctionne pas. (Commande RELOADSCRIPT)  [FAIT]
- Corrigé les rechargements de plugins
- [TODO] Corriger les commandes Chat & Console, [FAIT]
	- rien ne fonctionne en chat et plein sont bugés dans la console.
- [TODO-BUG] Les maxLaunchByTurnByTarget bugent, on peut encore réattaquer la même personne et lui faire mal.

0.0.91.3 [19 Mai 2013]
- [TODO-BUG] Corriger le kick des clients qui bug en TABARNAK   [FAIT]
	- Le client dofus ne s'apercoit meme pas du kick, il reste ouvert
	- Quand on veut se reco ca dit qu'il est déjà co ....	
- Corrigé le rechargement des scripts en mettant l'autoCommit des SQL à true	
- Ajouté les colonnes initialScheduleDelay et timeUnit dans table de scripts
- Ajouté champs kickOnExceptionCaught et banOnExceptionCaught	dans la config game + installé dans GHandler.exceptionCaught
- Plein d'affaires ;o Genre rush pour corriger les bugs de serveurs et IoSessions qui se ferment pas .. ><
	
	
0.0.91.4 [21 & 22 Mai 2013]	
- Trouvé pouruqoi(en qq sorte) les session client se closait pas quand on rebootait
	- C'est à cause du this.stop(); meme s'il est après les kick, cest lui qui fuck tout
- Déplacé le CWorld dans le GServer au lieu de dans GWorld
- Déplacé le loginserv.boot en optionnel quand on charge les services serveurs dans 
	- Management.Servers.bootLoginServers
	- Mtn ils bootent seulement si le enableOnLoad est true dans la bdd, pareil que pour les gameserv
	- Ceux qui mettent false pourront donc booter + on leurs serveurs grâce au Tool
- Corrigé donc la fonction de reboot dans les GServer, elle marche mtn.
- Corrigé aussi les kick de gclient lors de reboot, d'exceptions, packet non-conforme, etc.
- Travaillé sur les applications Android: http://www.siteduzero.com/informatique/tutoriels/creez-des-applications-pour-android/
- Checké Atomium (lib pour cqengine de Blackrush) et CQEngine (lib pour nosql) et NoSQL 
	- C'est puissant, à essayer, ça pourrait être mieux que c'que j'ai
	- [TO_TEST/TODO] tester atomium	
- Corrigé l'installaton de WindowsBuilder pour pouvoir dev le CTool, enfin..	
- Créé plusieurs abstractions pour standardiser la création de plugins avec GUI comme dans le CTool
	- Mais finalement j'ai excluse le source package, 
	- c'est pas vraiment bon en fait comme truc vu qu'on peut pu utiliser de static :/
- Créé un projet SynClient dans le workspace CTool
	- Le client de management sera donc distribué comme plugin sur le CTool
	- On pourra leur donner un CTool qui ne contiendra QUE ce plugin si on veut
	- Et donc garder l'exclusivité sur tous les autres plugins (Editeur de map,etc)
- Créé toute la structure principale du SynClient
- Commencé l'UI du SynClient, un peu dur à répliquer mes visions sur WindowsBuilder.
- Travaillé sur EhCache et Terracotta, c'est crissment sékelle leurs lien de dl et tous leurs jar qu'il faut chercher à lautre bout du monde
	- c'est chian, j'ai un bug et j'arrive pas à trouver le terracotta toolkit là...
	- Créé un dossier ehcache2.7 sur le bureau avec tout ce qu'il faut dedans, 
		|- plz ne pas déplacer ce dossier.


0.0.91.5 [23 Mai 2013]
- Créé UI MainWindow dans SynTool
- Créé UI SocketOptions dans SynTool
- Créé UI ShortcutOptions dans SynTool
- Créé UI Console et une autre Console pour l'envoie de packet dans SynTool
- Créé classe Shortcut
- Créé enum ShortcutAction et ShortcutContext
- Établi un système de shortcuts clavier configurable via une table dans l'UI ShortcutOptions
- Créé un parser et un sender dans SynTool
- [TODO] Faire l'UI de connexion de compte sur le SynTool
- [TODO] Faire une UI avec des patterns de packets à rentrer dans la console pour pouvoir les envoyer
	- ou avoir un bouton pour les envoyer directement à partir de cette UI
- [TODO] Ajouter une configuration au SynTool pour mémorer p.ex. les ndc+mdp, les shortcuts, options, etc
- Changer l'interface IParser en abstraction AbstractPacketParser
- Ajouté methods parse(TClient c, String packet) et parse(LClient, packet) dans AbstractPacketParser
- Ajouté method parse(TClient c, String packet) dans ParsingManager
- Implémenté parse(tclient, packet) dans le CrystalParser dans le PluginParser en plus de l'ancien parse(gclient
- Créé les packets 001 et 002 pour les liaisons ToolServer/Client
- [TODO] : Corriger le packet de listOwnedLoginServers (002) dans les ToolServers/Clients [FAIT]
	- il bug, il envoie que mon User n'a aucun serveur
- Créé classe Users extends ArrayList<User> implements IService
- Ajouté le Service Users aux Syn.Services	ainsi que sont constructeur + boot()
- Ajouté le chargement des Users dans SQL.Management.loadUsers dans le Users.boot
- Ajouté method get(String id) dans Users
- Ajouté method get(username, password, ip) dans Users
- Créé classe Perspective et View dans le SynTool
- Créé HashMap<name, Perspective> dans Datacenter dans le SynTool
- Créé HashMap<name, View> dans Datacenter dans le SynTool
- Refait toute la gestion des windows grâce à l'objet de vue et l'hashmap
- Les menus Show View, Options, et Open Perspectives sont maintenant dynamiques:
	- Ils fonctionnent en fonction de ce qu'on a ajouté dans les HashMap de vues et de perspectives
- Les perspectives fonctionnent.
	

0.0.91.6 [24 Mai 2013]
- Corrigé le query de création de perso, il y avait un ",?" de trop qui faisait buger
- Corrigé les commandes console que j'avais enlevées lors de la grosse refonte.
- Corrigé els commandes chat: 
	- Dans le ParsingPlugin, ça faisait if(getPlugin("ChatPlugin") != null)
	- Alors qu'il fallait if(getPlugin("Chat") != null)
	- C'est donc bon maintenant :)
- 

0.0.91.7 [27 Mai 2013]
- Créé classe abstraite	AbstractSqlService implements IService
- Renommé l'ancienne classe SQL en SqlServiceMySql extends AbstractSqlService
- Créé classe SqlServiceOracle  extends AbstractSqlService
	- Commencé à implémenter une nouvelle manière de gérer les sql avec le driver d'Oracle	
	- (J'cherche les DataSource là actuellement ....)
- Changé tous les objets sqlService de MySql pour des AbstractSqlService (Dans Syn.Services, GServ, LServ, etc)
- Ajouté un bouton "Enter Line" dans l'UI Console sur l'SynTool
	- + Ajouté un barre de statut qui montre le numéro de la ligne et de colonne actuel du curseur.
		- + la string de la ligne actuelle.
- Lu bcp de doc sur les connections et drivers sql et la jdbc, j'commence à comprendre un peu ;o
- Dans SQlServiceMysql :
	//TODO com.mysql.jdbc.Driver d = new com.mysql.jdbc.Driver();
	//TODO Connection c = d.connect("", null);
- [TODO] Compléter l'implémentation du SqlServiceOracle  [FAIT]
- Commencé un projet MmorpgClient dans le workspace Tool
- Créé une MainWindow dans le MmorpgClient avec un attempt à faire une barre de sort/item avec seulemtn swing/awt
	- [TODO] Trouver comment faire ses propres composants avec ses propres images/délimitations :)
- Travaillé sur dissert philo, étude hydrau+modifier, etc
- [TODO] Combats !!!


0.0.91.8 [28 Mai 2013]
- Créé le getConnection du SqlServiceOracle.  Ce servie est prêt à être testé.
- Je retourne coder les combats ;) en commencant par les maxLaunchPerTurnPerTarget des spells
- Downloadé plein de models blender pour mon mmorpg :3
- Modifié la classe Moar dans le PluginActions en objet 
	- et séparé la method applySpell en plusieurs methods pour être plus clair dans les étapes.
- Créé interface IActionFactory dans Syn.Externals.Plugins.Interfaces
	- + Ajouté un objet d'IActionFactory dans l'ActionsManager.
- Créé classe ActionFactory dans l'ActionsPlugin pour implémenter IActionFactory
- Ajouté la création+setting de l'ActionFactory de l'ActionsManager.
- Implémenté plusieurs types d'actions dans l'ActionFactory	
- Enlevé la ligne "p.getActions().push(a)" dans le GameParser.onAction
- Changé tous les new GAction(blabla) qu'il y avait partout pour des ActionsManager.getFactory.newXXX
- Corrigé tous les bugs de GAction qu'il y avait en envoyant des packets
- Corrigé les maxLaunchByTurnByTarget + réarrangé tout ça, 
	- ils sont maintenant applicables seulement aux targets en zone de case simple.
	- les autres zones ne sont pas gérées (C'est fait exprès, l'offi non plus ne le fait pas)
- Rennomé SM.Game.GA_MAP en GA_LAYER
- Ajouté methods GAS_LAYER et GAF_LAYER dans SM.Game
- Ajouté method toString dans GBuff
- Corrigé l'application des buffs de fin de tours dans GFight.endTurn()
- Bougé le if(allPeopleFromATeamAreDead){endFight();}  dans endTurn(); au lieu de endRound();
- Créé SchedulingA: FIGHT_TIMER pour les Task d'ExecutorThread.
- [TODO] peut-être rajouté une ArrayList<GAction> sequencer pour ordonner les actions dans le combat
	- et les exécuter une à une
- Ajouté un ThreadPoolExecutor fightTpe dans ThreadsManager 
	- + method updateFightTimingPool
	- + champs numberOfFightsInWorld
	- + champs numberOfFightsByTimingThread dans Constants
	-> bougé toutes ces conneries dans une nouvelle classse FighsThreadsManager au lieu du vrai ThreadsManager
- [TODO] la Task de FIGHT_TIMER et la détermination de quel thread fait .endTurn sur quelle fight et à quel moment.


[23:20:59] Robyn: manque pas grand chose pour les combats ..
[23:21:20] Robyn: manque les glyphes/pièges quand on fait des mouvements
[23:21:30] Robyn: le tacle
[23:21:57] Robyn: la vérification totale des cells quand on fait des mouvements en fait (si elles sont marchables, si elles sont occupées, etc)
[23:22:53] Robyn: et c'est tout. le reste c'est juste de rassembler tout ça dans un truc qui gère les tours et qui envoie quelques packets
[23:23:41] Robyn: me demande encore comment j'vais les implémenter ces "tours" par contre
[23:24:16 | Modifié (23:24:24)] Robyn: de quelle manière je vais trigger les fin de tours (et ping)...
[23:25:26] Robyn: si j'mets un thread qui vérifie le timer du tour pour chaque combat ...
[23:25:59] Robyn: le truc avec les ping, c'est que ça peut être hacké
[23:26:14] Robyn: donc au pire
[23:26:51] Robyn: j'mets un thread qui s'occupe de timer, j'modifie le client pour enlever le packet "ping" et j'ban tout le monde qui utilise le mauvais client.
[23:27:37] Robyn: ouaip
[23:27:55] Robyn: un schedule thread devrait faire l'affaire.
[23:28:55] Robyn: j'ai juste à créer des schedulethreads qui s'occupent chacuns de plusieurs combats 
	- (pool de fight dans l'objet arg de la task)



0.0.91.9 [29 Mai 2013]
- Créé classe TaskFactory + donné un objet au ThreadsManager 
	- (il est donc overridable si on veut sa propre implémentation)
- Ajouté quelques methods newXXX dans TaskFactory
- Ajouté methods newxxx dans ThreadsManager 
	- mais qui prennet une Task en arguement au lieu du SchedulingA et des Object...param
- Converti tous les call à threadsmanager.newxxx(schedulingA, params...) 
	- pour des call au newxxx(task)
- Créé une classe Sequencer, sauf que c'est de la merde :(
	- c'est bien beau d'avoir un sequencer d'effets ou d'actions, 
	- mais j'peux pas l'appliquer à personne là, me faut un target et caster u_u
- [TODO] Essaie en ce moment d'enlever toute la deep magic que j'ai foutu comme une merde.
	- Y'en a dans EffectsManager.apply(effect, caster, target, parameterholder) (En plus cest à chier comme args))
	- Dans GAction.setSpecialArgs(object) -> on a mtn l'ActionFactory pour ça
	- Peut-être faire une factory d'Applicable :(
		- style ApplicableFactory.newDamagingEffect(caster, target, spell, arme, effect)
		- style ApplicableFactory.newInvisibilityEffect(target, effect)
	- Ou sinon on fait une EffectFactory pareille comme l'ActionFactory 
	- une factory de ParameterHolder? :'( ?? :'(
	- j'sais vraiment pas :'( 
- Ajouté method sendStartFightPackets dans GFight pour envoyer les packets de début de combat 
- Ajouté  ENTER_FIGTER(905) dans l'enum de GameActionType
- Ajouté method newEnterFightAction dans l'ActionFactory
- Ajouté envoie du packet d'action 905 au lancement d'un combat pvm dans GFight.newPVM
- Ajouté packet GJK dans SM.Game
- Ajouté champs fightStartTimerTime et fightTurnTimerTime dans la GConfig dans la bdd
- Ajouté method isSpectator(GPersonnage) dans GFight
- Créé enum FightTeam dans Enums -> attacker = 0, defender = 1, spectator = 2, else = 3
- Modifié tous les teams.get(x) dans GFight pour correspondre aux FightTeam de l'enum
- Ajouté envoie du packet GJK au lancement d'un combat pvm dans GFight.newPVM
- Travaillé en tbk sur la reconstruction du .fla du loader
	- Presque réussi, j'ai juste des putains de problèmes de linkage de classes u__UU
	- J'ai enlevé la protection de base qu'y avait avec flasm (l'truc qui faisait dire "protégé par l'auteur" quand on ouvrait avec sothink)
	- J'ai testé plein d'affaire avec les fkn noms de linkage et linkage de classes .as
		- c'est fkn chian
	- Mais trouvé qu'il faut mettre les sources avancées (ank,dofus,mx..) à coté du .fla pour qu'il les utilise
- Ajouté packet SM.Game.GP 
	- [TODO] Corriger packet GP pour envoyer les vrais positions de combat
- Changé les args du GFight.getCharacterTeamID(int characID) pour (CombativeCharacter c)
- Ajouté GActionType ETAT_PORTE et ETAT_PORTEUR qui réfèrent tous deux à l'enum PlayerState
- Ajouté method hasState dans CombativeCharacter	
- Ajouté method newStateAction dans ActionFactory
- Ajouté l'état InFightReady dans l'enum de PlayerState
- Ajouté packet SM.Game.GR et GR_LAYER -> callé dans GameParser.onGameReady (recv packet GR1 ou GR0)
- Commencé à compléter le onGameReady, 
	- l'état InFightReady est mtn ajouté/enlevé quand on est prêt ou pas
	- il manque : 
-  /*
	* [TODO] dans GameParser.onGameReady
	* send quelques packets dont:
	* GIC (GameInfo), 
	* GS (GameStart),
	* GTL (GameTurnList->TimeLine), 
	* Gd (Gamedefi->challenges), 
	* GTM (GameTurnMiddle)
	*/


0.0.92 [30 Mai 2013] 
- Ajouté de la javadoc aux dernières methodes de packets que j'avais ajoutées dans le SM.Game
- Enlevé le boolean "addActionToOthers" dans le SM.Game.GA_LAYER
- Corrigé la method SM.Game.GR_LAYER qui n'envoyait pas le packet à la bonne personne (envoyait au perso au lieu d'à tous les characters du layer)
- Ajouté packets GIC, GS, GTL, GTM + plusieurs variantes pour les envoyer à tous les gens de la fight
	- + Ajouté des calls à ces packets dans le f.startFight 
- Ajouté method isEveryoneReady dans GFight
- Ajouté parsing du packet GR (GameReady) dans PluginParsing.GameParser
	- Ajouté le renvoie du packet GR 
	- Ajouté un call à f.startFight() dans le parse du GR si le isEveryoneReady == true;
- Replacé le .organizeTimeLine dans le fight.startFight à la place du .createNewXXX
	- Pcq de toute facon, on envoie le packet d'afifchage de timeLine (GTL) que quand le combat est commencé 
	- Et j'ai pas envie de refaire .orgainzeTimeLine chaque fois que qqn quitte ou rejoind le combat.
- [TODO-BUG] Le CombativeCharacter.getFight return null; [FAIT]
- Ajouté l'envoie du packet GIC à la fin du sendInitFightPackets
- Changé method SM.Game.GJK pour GJK_ALL et modifié pour envoyer le packet à tous les characters
	- + déplacé le call dans fight.createNewXXX au lieu de dedans le sendInitFightPackets
- Testé le lancement de combats, voilà ce que ça donne : http://pasteboard.co/2Py9RWPZ.png
	- Et oui j'ai testé avec 2 persos co, l'affichage/désaffichage sur chacun se fait bien :)
- [TODO] Faire le packet pour voir la liste des combats de la map [FAIT]
- [TODO] Faire le packet pour afficher les épées-flags sur la map pour pouvoir rejoindre le combat
- [TODO] Faire les packets de demande d'aide, bloquer l'accès au combat, bloquer pour les membres du groupe
- [TODO] Faite la fonction pour rejoindre un combat en combattant ou spectateur.
- [TODO] Vérifier toute ma structure actuelle de packets et le code des methods dans SM.Game
	- j'pas sur qu'ils soient parfaitement bons mes packets et ça serait une bonne idée de les reconstruire
		- pour avoir des noms uniforme (avec les xxx_fight, xxx_layer, etc)
- [TODO] Regarder combien de ram prendrait 4 ActionListeners de triggers par map 
	- + comparer à des objets Trigger spécials.
- [TODO] Ajouter les places de combat sur toutes les maps 
	- ou créer une methode de génération de places aléatoires 
		- en prenant compte des cells marchables etc qu'on doit déparser de la mapData.
- [TODO] Coder le bouton "annuler" quand on entre en combat, mais qu'on veut annuler et resortir ;x
- [TODO] Faire la reconnection en combat
- [TODO] Ajouter la possibilité de quitter un combat (différentes manières: abandonner,annuler,sefairekicker...)
- [TODO] Rajouter le respawn popup des GMonsterGroup à la fin d'un combat.
	- [TODO] Ajouter les possibleMonsters par subareas
	- [TODO] Ajouter les subAreas aux Areas (Il en manque, y'a des subArea comme Brakmar qui sont pas installées)
	- [TODO] Ajouter les archimonstres



0.0.93.1 [31 Mai 2013]
- Corrigé le isCharacterInFight, il fonctionne maintenant.
- Ajouté method onGamePosition dans le GameParser
- Ajouté method abstract getTeamAlignment dans GFight 
- Ajouté parsing du fL et fD dans FightsParser
	- ajouté method onList
	- ajouté method onDetails
	- et dans la liste de combats en cours de la map.
- Ajouté method de packet SM.fights.fL. 
	- [TODO] à finir [FAIT]
- Déplacé l'ancienne enum FightTeam de Enums à dans GFight en sousclasse
- Créé enum FightTeamType qui est pour les icones de type de team sur les flasg sur la map
- Corrigé packet fL
- Ajouté method  SM.fights.fD pour le packet qui envoie la liste des combattant d'un combat dans la liste de combat de la map.
- Changé l'array GFight[] dans Map pour une ArrayList<GFight>
- Ajouté method getTeamType dans GFight
- Ajouté plein de if(char.getLayer == p.getLayer) 
	- dans SM.chat pour corriger les bugs de layers sur les messages envoyés ainsi qu'émotes
	- ainsi que dans SM.emotes
	- ainsi que dans GM.Game -> sur les packet de GM
	- partout dans le SM ou ctait bon quoi...
- Retravaillé le code du GFight.newPVM, 
	- réorganisé pour corriger des problèmes d'affichage, 
	- enlevé beaucoup de lignes d'anciens commentaires/codes inutiles
- Créé interface Listener
	- Ajouté method fire() , getType() et listen(JoinPoint joinPoint)
- Créé aspect FightDeconnectedListener implements Listener
	- Implémenté les methods getType et fire 
	- Implémenté listen(JoinPoint joinPoint) avec un advice @Before("execution (* GFight.startTurn(..) )")
		- Comme ça ce listener va fire à chaque fois que 
	- Ajouté un field GPersonnage et byte turnsDeco = 0;
- Créé classe ListenerFactory pour créer les différents types de listeners
- Ajouté une ArrayList<Listener> dans GFight
- Bougé l'enum ActionListenerType de l'actionsPlugin à dans le packge d'enums dans Syn
- Créé classe ObservableState extends Observable 
- Créé classe FightDeconnectedObserver
- Ajouté un ObservableState aux GFight quicontiendra l'état machine actuel du combat:
	- TURN_START, TURN_END, ROUND_START, ROUND_END, FIGHT_START, FIGHT_END, etc
	- Ces états sont dans l'enum ActionListenerType
- On pourra ajouter des observers au ObservableState comme le FightDeconnectedObserver
	- Et ensuite faire state.notifyObservers() juste après avoir resetté le state
- Ce nouveau systeme est pour remplacer les IListeners en AOP que j'adorais 
	- mais qui étaient impossible :'(



0.0.93.2 [2 Juin 13]
- [TODO]: ajouter dans la gconfig le nb de tours 
	- qu'il faut quand on est déco du combat pour en être kické (20 normalement)
- Ajouté type ON_FIGHT_RECONNECTED dans ActionListenerType
- Ajouté ceci dans GameParser.onInfos (packet GI)
	GFight f = p.getFight();
	if(f != null){ p.onAddedToMap(p.getMap()); 
	- Ajouté aussi ceci:
	f.getStateMachine().set(ActionListenerType.ON_FIGHT_RECONNECTED.ordinal()).notifyObservers(p);
	- Pour enlèver l'observer qui comptait les tours déconnecté de la liste de l'observable
		- et envoit msg "Persox s'est reco en combat !" 
	- C'est encore un [TODO] à finir.
- Supprimé la method getType dans FightDeconnectedObserver
- Avancé la method update par contre
- Modifié le .kick dans GClient
	- Un nouvel Observer est ajouté au combat à ce moment comme ça:
		- f.getStateMachine().addObserver(new FightDeconnectedObserver(p));
- Ajouté des if(cc.getCharacterType() == CharacterType.PLAYER)
	- à plusieurs endroits dans le SM.Game		
- Modifié le PlayerState[] states en ArrayList dans CombativeCharacter
- [BUG] Le getFight du joueur return null quand il essaie de se reconnecte en combat. [FAIT]
- Il est possible de faire "pret" en combat et de choisir sa position de départ.
- Créé package Observing pour y mettre les Observables et les Observers
- Corrigé le GFight.isEveryoneReady qui renvoyait toujours true; Il foreach mtn les teams excepté les spectateurs.
- Joué à wakfu ;I
- [BUG] Y'a un coliss de problème avec le weaving d'aspectj mtn quand j'run Syn sur eclipse >.>



0.0.93.3 [4 Juin 2013]
- Réinstallé le plugin de YourKitProfiler 9.0.8, aucune idée poruquoi il avait disparu..
- Travaillé sur le SynTool:
	- Ajouté package EmuObjectsRepresentations dans UIs
	- Créé classe UI Representations qui est une jframe qui contiendra les objets de representation
	- Créé classe UI Personnage qui est une jinternalframe qui sera contenu dans la UI de Representations.
	- Créé classe UI Fight qui est une jinternalframe qui sera contenu dans la UI de Representations.
	- Créé classe UI Map qui est une jinternalframe qui sera contenu dans la UI de Representations.
- Travaillé sur le bug de getFight null dans GFight.createnewpvm et dans organizeTimeLine, etc. [FAIT]
- [TODO] Il faut absolument enlever l'envoi du packet GDM quand on entre en combat.  
	- Cela créé une doublure de l'envoie des SM.Game.showAllSprites
	- [FAIT] dune manière, GDM encore là: mit un truc sur le recv GI ]
- [BUG] Quand on essaie de se reconnecter à dofus après s'etre déco en combat,  [FAIT]
	- ça nous met l'erreur: "Ce compte est déjà connecté"
	- À voir dans LAuthentficationHandler ligne 45
	
	
0.0.93.4 [5 Juin 2013]
- Bugs de reconnection avec le compte déjà connecté corrigé
- Bugs de nullPointerException dans le GPerso.onSelected corrigé
- Ajouté constante statis final byte baseLayer = 0 dans Map
- Commencé le endFight dans GFight
- Callé super.endFight dans FightPvm
- Travaillé sur la reconnectino en combat: gclient.kick, gfight.endfight, etc
- Ajouté method GJK dans SM.Game
- Ajouté method sendPlacementFightPackets(p) dans GFight
- Ajouté method sendActiveFightPackets(p) dans GFight
- Donc restructuré les envois de packets. (En ai enlevés qqs dans startFight et createNew, bougés d'autres, etc)
- Ajouté method getFreeCellRandom(Map m, int minRange, int maxRange) dans FormulingManager->PathUtils
	- + implémenté dans l'PathUtils dans le FormulingPlugin. 
- Ça avance: http://pasteboard.co/8DVyA2C.png
- On voit donc tout ce qu'il faut bien comme faut quand on se reconnecte c'Est identique comme on l'avait laissé.
- On peut presque lancer des sorts en combat, tu réessayera, c'Est assez étrange comme bug en fait, il doit me manquer un packet
- Là les trucs à corriger cest: 
	- [TODO] L'affichage des mobs sur leurs pos: gfx et cercles noirs qui sont supposés etre rouges et bleus
	- [TODO] Corriger l'utilisation de sorts en les sélectionnant + ciblant avec la souris
	- [TODO] Afficher les buffs quand on clique sur le character dans la timeline
	- [TODO] Contrôler les mouvements (GA001) quand on est en combat.
- [TODO] Corriger prob de ram avec les substrings : sur les gActionListener et probablement plein d'autres places:
	- Quand t'as cette string: "E:3ea#0#0#Bonjour, ici mon message de fou@FF0000#0|A:1002;%iobject%"
		- Pis que tu fais un substring pour l'effet et un pour l'action,
		- Ben en faite ça garde toute la string totale originalle dans la substring, cest juste l'offset qui est changé
		- Alors faudrait faire un str = new String(total.subtring());
		- Pour éviter de prendre toute la ram de trop.
- Les gActionListeners prennent environ 400bytes chacun quand ils possèdent un seul GEffet
	- 600 bytes pour un gActionListener avec une GAction + un GEffect : http://pbrd.co/11iQZ2c


0.0.93.5 [6 Juin 2013]
- Travaillé sur Synus:
	- Ajouté package Misc/
	- Ajouté package dof/
	- Ajouté package Network/
	- Rename package gfx/ en graph/
	- Ajouté classe OverHeadTextMod dans Misc/
	- Ajouté classe Console.as dans graph/
	- Ajouté classe Utils dans le package Utils
	- Ajouté un movieclip Console dans le .fla de Synus qui est linké avec la classe graph.Console
	- Ajouté le parsing de commandes quand on click le btn Enter sur la console:
		- Ajouté commande EXE: pour caller une fonction contenu dans le texteinput ex: "Misc.OverHeadTextMod.active"
		- Ajouté commande ATT: pour attribuer une valeur à n'importe quelle variable. ex: "Misc.OverHeadTextMod.backup=null"
		- [TODO] Commandes PE, PC et PACKETS: à faire
	- Ajouté classe DataProcesorImpl dans dof/
	- Ajouté classe SenderImpl dans dof/
	- Ajouté classe Parser dans Network/
		- Ajouté fonction send("") qui call le send officiel overridé par SenderImpl
	- Ajouté classe Sender dans Network/
		- Ajouté function parse qui est calllé par DataProcessorImpl
		- Ajouté fonction parseApacket qui parse un packet commencant par 'A'
	- Ajouté function load() dans Utils.Config
		- Ajouté variable _global.DEBUG = true;
		- Ajouté variable _global.RECORD_PACKETS = false;
	- [BUG] Genre tous les components de Dofus sont supprimés en chargeant mon module
		- Les boutons, les textes, etc ne s'affichent plus et font buger total
	- [TODO] Compléter l'affichage des packets entrants/sortants

0.0.93.6 [7 Juin 2013]
- Travaillé sur Synus:
	- Ajouté classe OutputConsole
	- Ajouté MovieClip OutputConsole
	- lskadmlkasmndf

0.0.93.7 [10 Juin 2013]
- Corrigé plusieurs choses sur le packet d'affichage GM des monstres
	- ajouté les resists pa/pm (esquive)
	- ajouté des ';' qui manquaient.
	- mit seulement 3 virgules (",,,") dans l'accessories packet de base au lieu de 4 (offi comme ca)
- Ajouté un if(cc != starter){ normalMap.updateSpriteList(MapAction.ADD_SPRITE, cc); }
	- dans la boucle qui settait le layer à tous les combattants
	- comme ça ca ajoute les monstres à la map et les affiches en plus.
- Changé le packet GP des positions d'équipes pour un autre un peu plus complet et simple 
	- (il a des cases pour chaque équipe xd)
- Corrigé le packet d'action d'état en corrigeant
	 - la création d'action d'état dans ActionFactory.newStateAction (ActionsPlugin)
- Réorganisé plusieurs packets dans GFight en pvm:
	- le GDM n'est plus envoyé,
	- Le GIC est rajouté dans .startFight
	- l'ordre des packets dans le constructeur GFight est refait.
	- L'ordre de tous les packets de combats jusqu'à maintenant est parfait par rapport à l'officiel
	- [TODO] Il manque seulement les bonnes structures de packets de GM en combat :/
- [BUG] Quand on se déconnecte pendant la phase de placement, y'a plein d'erreurs générées
	- [BUG] Quand on essaye de se reconnecter en combat après cet autre bug, ça dit qule compte est déjà co
- [BUG] Les monstres ne s'affichent toujours pas dans la phase de placement ni phase active
	-> [CORRECTION]: Trouvé qqc: renvoye le packet GIC et GTM avant le GM (tjr avec la bonne cell)
- [BUG] Les cercles de couleur d'équipe sous les combattants sont toujours noirs.
- Modifié la commande GETMAPSPRITE pour afficher le parametre "nom:" de tous les abstractchar
	- et aussi le layer de tous les isprites


0.0.93.8 [13 Juin 2013]
- packet de GM des monstres en combat, j'y comprend vrm pas grand chose esti u_u
- ajouté un boolean "forceZero" 
	- pour quand meme envoyer le packet ILF quand le nombre de pdv récupéré est de 0  
- changé l'ordre des packets des états porté/porteur dans GFight.sendPLacementPacket
- Enlevé l'envoie des résistances dans GMonster,getSpritePacket
- Changé le SM.Game.fC_ALL pour fC_LAYER qui l'envoie seulement au layer de base de la map.
- 


0.0.94.9 [17 Juin 2013]
- Créé classe FightFactory dans GameObjects.Fights
	- Bougé toutes les .createFight dedans
- Corrigé un bug en mettant l'état de la fight à PLACE à L'endroit ou on le mettait à INIT 
	- + updaté des genre de if(fight.state == FightState.INIT) pour des == FightState.PLACE
		- à plein d'endroits dans le ParsingPlugin ou autre (surtout le GameParser)
- Maintenant on voit des cercles de couleurs en dessous des sprites en combat
- [TODO] Faut faire le packet GM de personnage en combat, il n'est pas pareil [FAIT]
- Les couleurs de cercles s'affichent mtn aussi bien pour les perso que les monstres.
- [TODO] Les sprites des monstres ne s'affichent toujours pas... :/  [FAIT]
- Ajouté packet GM de personnage en combat.


0.0.95 [18 Juin 2013]
- Corrigé l'affichage des sprites monstres en combat:
	- Dans FightFactory.createNewPVM, 
	- au moment ou on iterate tous les combattants pour setter les layer/randomcell/etc..
	- j'ai juste changé l'orientation de 0 pour qqc de valide en combat.
	- j'ai ajouté un cc.setOrientation(FormulingManager.getOrientationBetweenCellsInFight(normalMap, cc.getCellID(), p.getCellID()));
	- qui change l'orientation 
	- J'call un .toDiagonal dessus aussi pour être sur d'avoir une orientation conforme aux combats.
- Les sprites regardent en direction de l'autre équipe au début du combat (Orientation settée là ^ )
- Ajouté methods toDiagonal et toOrthogonal dans l'enum Orientation.
- Rajouté l'envoie des résistances des monstres dans leur packet GM de combat
- [TODO] Packets GTS, GTF, GTR, timers, passer son tour [FAIT]
	- [TODO] Dans les timers, empêcher de passer son tour lorsqu'il reste moins de 5 seconde avant la fin du tour
- [TODO] Affichage des "flags" sur la map pour pouvoir rejoindre le combat.
- Ajouté les methods de packets GTS_FIGHT, GTR_FIGHT et GTF_FIGHT dans SM.Game
- Ajouté l'envoi du GTS dans GFight.startTurn au début du commencement du tour
- Ajouté l'envoie du GTF + GTR dans GFight.endTurn au début de la fin du tour.
- [TODO] recevoir les packets ping, qping et rping
- [TODO] Faut finir le parsing des packets GT et Gt (GameTurnOk et GameTurnEnd) [FAIT]
- Ajouté method setExceptionHandler dans Core.Syn
	- C'pour mettre un handler qui gère toutes les exceptions qui n'auraient pas déjà été handlées/catchées
- Callé setExceptionHandler dans Syn.main 
- Renommé la classe ActionsPlugin.Moar.Moar en SpellApplication
- On peut se déplacer et lancer des sorts en combat
- Corrigé un bug dans EffectsPlugin.Application.apply: 
	- il y avait un cast (GPersonnage) sur un AbstractCharacter ou Combative chais pas ,
	- mais c'était illégal car c'était un monstre.
- [TODO] Dans les déplacements (path+nodes) , 
	- faire une vérification de plus pour n'accepter que des déplacements diagonaux (Orientation.isDiagonal)
	- au lieu d'accepter les 8 directions.
- [TODO] Actualiser les PM lorsqu'on se déplace + Envoyer le packet As  [FAIT]
- [TODO] Faire une vidéo de présentation en montrant que les combats fonctionnent ? (Avec Camtasia Recorder) [FAIT]
- [BUG] J'me suis fait déco en lancant ronce multiple dans le vide. [FAIT]
- [TODO] EffectFactory pour créer les effets et leur parameterHolder pour l'apply.. 
	- Genre une method par type d'effet puisque chaque effet a ses propres paramètres, sa propre manière de fonctionner.
	- Après, tant qu'à y être, on peut ptete faire une method d'application pour chaque type d'effet au lieu du switch case
	ha merde, en fait on peut meme pas faire deffect factory de ce genre puisqu'on sait même pas quel est l'effet qu'on utilise
		- tsey quand t'es dans l'Application de sort et que tu fais for(geffect e : spell.effects) { apply(a) }.. ben là ...


0.0.95.1 [24-25 Juin 2013]
- Créer classe ServerStrategyFactory dans la UtilsLib
	- C'pour définir de quelle manière fonctionnent nos LServer,GServer,TServer
	- J'sais pas encore comment j'vais faire, mais en ce moment ça s'enligne
		- sur les décorators/proxy, 
	- Le but est d'implémenter l'interface Server dans NettyServer/MinaServer
	- et d'extend une de ces deux classes là sur les L/G/TServ. 
	- Sauf qu'on ne sait pas laquelle sera extendée, il faut que ca soit configurable
		- et qu'on puisse faire qqc comme LServer = ServerStrategyFactory.newMinaServer();
- [TODO] : Redis distributed cache avec Jedis + JOhm
- [TODO] : Timer combat avec buffers, strategy d'ajustement automatique du buffering [FAIT]
- Ajouté classe MultiPerfs dans LibUtils.Tests
- Implémenté le type de Task FIGHT_TIMER dans Syn-NewThreads.Task  (prototype)
- MinaServer (UtilLib) : on peut mtn réutiliser le même port en rebootant [FAUX->bug] [CORRIGÉ]
	- grâce à SocketSessionConfig dsc =  (SocketSessionConfig) acceptor.getSessionConfig();
	- dsc.setReuseAddress(true);
- Bougé la variable  short port des G/LServer dans MinaServer
- Gros problèmes de fermetures des sockets/sessions sous linux encore une fois u_U
- Réglé un problème de concurentModification dans GFight.endTurn sur le for(buffs)
- Travaillé sur le NettyServer (lecture DOC), sauf que ça sera pas faisable.
	- Pas sans grosses modifications partout
	- Puisqu'il n'y a pas de "IoSession" comme avec Mina, l'handler est complètement différent, etc.
- Ajouté long endTurnCurrentMillis dans GFight
- Testé un prototype du système de timers auquel j'avais pensé, ç va pas pire, mais faut bcp mieux ;)
	- (Dans Task)
	- En passant j'pense quil me manque un packet à envoyer au client quand on passe notre tour
		- Quand il passe tout seul c'est beau, mais quand on passe nous-même, y'a une différence mauvaise..



0.0.95.2 [26 Juin 2013]
- Travaillé sur les bugs avec le serveur mina et ses iosessions
	- Déplacé l'initialisation de l'acceptor dans le constructeur 
		- et laissé juste le binding et qq trucs dans le .start
	- Ajouté un for(acceptor.getmanagedsessions.values) session.close(true) dans le MinaServer.stop();
	- Remit le call à .stop dans LServer et GServer .off
- Dans SConfig.loadScripts -> les scripts sont mtn lancables avec uniquement un initialDelay si on le veut
- Ajouté dossier js dans Syn_scripts
- Bougé tous les scripts js dans js/
- Créé script exit.js dans js/ , il sert juste à caller System.exit(0);
- Ajouté le script exit.js sous le nom Exit dans la bdd dans syn_world0.scripts. 
	- l'ai mit pour qu'il ne se lance pas au démarrage, mais qu'il soit loadé et donc utilisable sur demande.
- Corrigé tous les bugs de socket mina et de sessions
	- Commande exit fonctionne parfaitement
	- Restarter l'application juste après se fait parfaitment (pas de BindException : Address already in use)
- Corrigé le .terminate dans GPersonnage qui lancait des nullPointerException vraiment bizarres
	- sur ses w.getInventory.terminate / w.getStats.terminate / ...
- YAAYYYAY !! :D
- Enlevé la variable short port dans TServer
- Mit ID et state en private dans TServer et ajouté le get/set pour l'ID
- Créé des Working Sets pour rassembler les projets qui ont rapport en un seul dossier 
	- (Ex: Plugins, libs, Tests..)


0.0.95.3 [27 Juin 2013]
- Refait les benchmark sur spymemcached, 
	- obtenu une moyenne de 0,45ms pour un get() dans une itération de 20 000
	- obtenu une moyenne de    8ms pour un get() dans une itération de 3
- Créé un nouveau projet NewTests dans le WorkingSet Tests, 
	- l'ancien avait plein de dépendances non-résolues 
	- et j'ai pas envie de me faire chier à les réparer
- Testé Quartz, un Job Scheduler, genre de Timer, c'est cool à date. (Dans NewTests)
- à part ça j'sais pas encore comment faire les timers pour les combats.
- Oublie pas de faire du scheduling de packets sur l'IA hein aussi
	- tu fais tous les calculs, applique tous les effets, etc 
	- et envoie les packets juste plus tard en schedule ;) max performances ;)

0.0.95.4 [28 Juin 2013]
- Bougé l'interface IService de Syn/Interfaces à dans UtilsLib/Interfaces
- Créé un socket client en php dans www/client.php :) pour pouvoir communiquer p.ex. avec le ToolServer
	- pour boutique, users, etc :)
- Créé un TServer sur Zen pour la boutique du site d'ouragan ou pour n'importe quoi d'autre :)
	- ca remplace l'ancien master server de merde :)


0.0.95.5 [30 Juin 2013]
- [BUG] Le GServer se ferme mal et créé un java.net.BindException: Adresse déjà utilisée
- Créé plugin InjectPlugin 
	- Créé interfaces Provider, Injecter, Overrider
	- Créé classe Providers
	- Créé providers GMonsterProvider,GMonsterGroupProvider,GPersonnageProvider
- TODO: Rendre tous les PluginManagers objet au lieu de statics. [FAIT]
	- Sinon les gservers ne pourront pas avoir leurs propres implémentations de leurs plugins
		- tout ce qui sera chargé sera static donc unique. 
		- Ex: le AbstractEffectPluginListener est statique dans EffectsManager
			- donc toujours le même pour tous les serveurs 	
- Créé classe PluginsManager dans Externals.Plugins.Managers
- Ajouté un PluginsManager à chaque GServer et déplacé leur ancien objet Plugins dedans.
- Ajouté un defaultPluginsManager dans le Management.Services
	- On va mtn charger les plugins dans Syn général en plus de ceux spécifiques à chaque gserv
	- Donc on pourra vider les tables de plugins des gserv et utiliser juste celle de syn
	- [TODO] [FAIT] Ajouter table de plugins dans bdd syn 
	- [TODO] [FAIT] Rediriger vers le default lorsqu'un des managers de plugin n'est pas créé dans ceux d'un gserv
- Remplacé toute référence statique aux managers par des ref. objet, ça fait vrm pas beau
	- je déteste ça comment cest dégueulasse
- Voilà, il est mtn possible d'avoir différentes implémentations des plugins sur chaque GServer
	- même si c'est sur la même instance de Syn (même JVM)
- [TODO] Terminer le framework de providers (ou factory, pt à renommer)
- Fonctionnement du nouveau framework de providers : 
	- Dans chaque classe d'objet qui requiert un provider injectable,
		- on créé une sous-classe NomDlaClasseProvider 
		- On créé ensuite une instance de ce provider dans la classe AbstractProviders 
			- dans Externals.Plugins.Abstractions
		- Ces providers peuvent être abstract et déclarer des méthodes abstract
			- qui seront overridées dans le PluginInject si on veut.
	- Lorsqu'on charge le plugin Inject, il faut lui envoyer l'event MiscEvent.Set_Server
		- avec le GServer en tant que source de l'event 
		- pour pouvoir setter la référence au GServer dans le plugin
- [TODO] Ajouter une config au PluginInject pour configurer les ProviderInjecters à injecter ?
- Donc, en bref, nos factories sont modifiables en runtime donc nos objets créés aussi
	- Pour cela, on peut faire (p.ex), dans le plugin (dans les overriders),
		- qqc comme GMonsterOverrider extends GMonster -> @Override public getColor1()return 999;
		- et modifier le GMOnsterProviderInjector pour qu'il 
			- renvoye un GMonster m = new GMonsterOverrider au lieu d'un simple gmonster :)
		- Ensuite pour modifier les GMonsters qui existent déjà bah on itérate 
			- sur toutes les instances de GMonster, on fait une copie en GMonsterOverrider
				- et on la set à la place de l'ancienne :), et voilà!  :)
- Il faut mtn envoyer un event MiscEvent.Set_PluginsManager à la place de l'ancien Set_Server
	- pour que tous les plugins puissent se placer dedans 
	- (en mettant le PM voulu dans l'object source de l'event)
- [TODO] Continuer de propager la stratégie de providers pour instancier nos objects en faisant 
	- gserv.getProviders.provideXXX.createNew(...);
	- Syn.Services.defaultProvider.provideXXX.createNew(); [TODO Mettre un default provider dans Services]
- [TODO] Faire implémenter AbstractProviders (Syn) à Providers (InjectPlugin) ??


0.0.95.6 [1 Juillet 2013]
- Créé un nouveau mode de timing pour les combat avec une DelayQueue
	- Créé classe DelayingFights et fais extend Delayed aux GFights
	- Ajouté un call à DelayingFights.queue.add(fight) dans FightFactory.newPVM
	- Testé tout ça, j'ai même fait un benchmark avec des test: https://gist.github.com/Crystals/5983a6edc3ec2e40c331
	- Malheureusement j'ai un problème avec mon implémentation du getDelay()
	- Il me semble qu'il faut leur donner en nanosecondes
- Ajouté param Event buildEvent dans pluginsLib dans loadPlugin
	- pour lancer un event au chargement du plugin, ceci me sert dans ce cas à setter le PluginsManager
- Ajouté method callEvent(Event e) dans PluginManager dans PluginsLib 
- Fini le framwork de providers et de pluginsmanager
	- Il ne reste plus aucune erreure
- blabla, c'beaucoup de travail tout ça.
- Ajouté une référence au PluginsManager dans chaque plugin 
	- Cette référence est settée grâce à l'event MiscEvent.Set_PluginsManager
	- Elle sert à pouvoir utiliser les FormulingManager, ActionsManager, etc du GServer.
- Rename AbstractProviders en ProvidersManager et déplacé dans Plugins.Managers
	- + déplacé l'instance de Providers du GServer dans le PluginsManager
- Fini le système de plugins Managers objets
	- Les ai mit en private au lieu de public
	- Ai ainsi enlevé toute référence directe aux variables pour être sur de ne pas viser des trucs null
	- Ai corrigé les getXXXManager pour qu'ils prennent en compte le PluginListener != null qu'ils contiennent
	- Ajouté la table de plugins dans syn
	- Vidé la table de plugins spécifique aux gameserver
- [BUG] [FAIT] Quand on essaye de off l'emu alors qu'il y a des gens en combat, les sockets ne se ferment pas 
- Corrigé un bug dans GClient.kick quand on est en combat et que la team devient vide à cause du perso qui s'en va
	- Corrigé un autre bug dans le même genre dans FightPVM.endFight, ajouté un return; 
		- juste avant le prototype de parsing du panel d'xp de fin de combat
	- Corrigé un autre bug dans le même genre dans le GMonster.terminate, le getDrops() était null
- Ajouté champs useDefaultPlugins dans la config des gameservers en bdd
- Corrigé un bug dans ConsoleParser et ChatParser:
	- Ils voulaient utiliser les console et chat plugins 
	- alors ils faisaient p.getserver.plugins.get("chat")
	- Mais étant donné qu'on ne les charge plus dans les gserver, bah ca retournait null
	- Alors j'ai fais genre if(p.serv.plug.get("chat")==null && config.useDefaultPlugs){
		- plugin = Syn.Services.defaultPluginsManager.plugins.get("chat"); }
- Ajouté "commande" pour le RELOADPLUG on peut mettre "default.ALL" en argument pour recharger les plugins du service par défaut.



0.0.95.7 [4 Juillet 2013]
- J'ai beaucoup joué sur minecraft cette semaine :x  
	- Et Theo me fait royalement chier,
	- Et j'ai codé sur Zen aussi, 
		- j'ai corrigé les timers, 
		- les achievements sont maintenant configurable à souhait, 
		- ajouté des points d'events (voir son changelog) 
- Là faut faire les putains de timers man, ca fait plus d'un mois que j'ai commencé u_U
- Go tester ça en mode debug et ajotuer les putains de packets qu'il manque.
- Au pire Tenkei peut leech les packets des combats sur l'offi.
- Parlé avec John sur wizpert.com, IL EST FUCKING AWESOME CE GARS OMG <3 
	- Il m'a montré les shared memory segments que j'pourrai utiliser pour séparer mes JVMs
	- et avoir un clustered cache sans même avoir à sérializer ni replicate.
	- Tout ce que j'vais .get() du cache sera une référence à celui-ci ! 
	- Donc toute modifications dedans se fait dans les autres nodes aussi !!!! HAAA CEST FOU <3
	- Et même pas besoin de refaire une tonne de .get(), on a déjà la bonne référence au cache !!!
	- J'ai c/c toute la conversation dans un .txt que j'ai c/c un peu partout dans mon dropbox:)
	-  Awesome awesomeness of fucking awesome, this is awesome, i love it <3
- 

0.0.95.8 [9 Juillet 2013]
- Bougé l'interface IExecutable dans la UtilsLib au lieu de l'émulateur Syn.
- Créé classe ExecutableScript dans la UtilsLib qui extends Script et implements IExecutable
- Changé l'exécution de la Task d'EXE_SCRIPT pour convenir aux nouveaux ExecutableScript
- [RÈGLE] : On ne doit plus utiliser Script dans l'émulateur, mais bien ExecutableScript.
	- En fait, la différence est que l'ExecutableScript contient un objet Future
	- qui lui donne la possibilié d'être .cancel(), .getDelay(), get() result, etc..
	- Il peut aussi être appliqué/schédulé directement avec des methods inclues à sa classe.
		- donc sans passer par un ThreadsManager comme j'ai fait jusqu'à maintenant.
		- Par contre, je réserve l'utilisation de ces methods aux endroits extrêmes
		- (C'est-à-dire aux endroits ou les ressources sont limitées 
			- et qu'on n'a accès à aucun ThreadsManager)
- Corrigé l'exécution de la Task d'INVOKE qui modifiait les param[] à chaque fois que la task s'exécutait
- Créé class SimpleIA extends AbstractIA dans SystemsPlugin.
- Créé int statique minimumIDinWorldIATable = 15001 dans CServers
- Créé ArrayList<SimpleIA> intelligences dans GameWorld et GlobalWorld
- Supprimé Simple IA qui était dans le SystemsPlugin.
	- Renamed AbstractIA en SimpleIA et changé en classe normale au lieu d'abstract
		- et bougé dans ConfigurationObjects au lieu de Plugins.Abstractions
- Créé table artificial_intelligence_config dans les worlds (game et global)
- [TODO] [FAIT] Ajouter colonne iaID dans monsters pour référencer l'IA qu'on veut lui attribuer
	- [TODO] [FAIT] Setter l'IA voulue dans l'instanciation des GMonsters (Dans le GMonsterProvider)
- Ajouté un objet SimpleIA dans CombativeCharacter 
	-> Même les personnages pourront être contrôllés par IA si on le veut.
	-> Peut-être donner la possibilité d'écrire sa propre IA à activer lorsqu'on se déconnecte en combat
	-> Le point d'en haut peut donner la possibilité de jouer 
		- avec un seul perso pendant que ceux des autres comptes sont contrôllés par IA 
		- (Ex: 4 comptes, 1 personne, 3 IA)
- Supprimé l'objet ArrayList<IExecutable> qu'il y avait anciennement dans GMonster
- Btw, une SimpleIA étant aussi un IExecutable, 
	- l'arrayList d'exécutables contenue dans les simpleIa peut 
	- donc elle-même aussi contenir d'autres SimpleIA.
- Ajouté method loadIntelligences dans SConfig 
	- + callée dans le static{} du GlobalWorld et dans le constructeur du GWorld();
- Créé classe MiscUtils dans package Syn.src.Misc
- Créé method parseStringToExecutables dans MiscUtils
- [TODO-FIXME] [FAIT] : Copier les tables  scripts/artificial_intelligence_config du game dans syn/global respectivement.
- [TODO] [FAIT] Ajouter le parsing des Macros Executables dans MiscUtils.parseStringToExecutables
	- [TODO] [FAIT] Ils pourront être utilisés de la même manières que les scripts, actions.. (Colonne actions dans commands_config, ia_config, etc)
	- [TODO] [FAIT] On fera une table sql pour les recenser qui sera presqu'identique à celle des scripts :)
- Créé abstract class ScriptsService<E extends ExecutableScript> extends Scripts implements IService
- Créé objet ScriptsService dans Syn.Services
- [RÈGLE] : On doit maintenant utiliser ScriptsService au lieu de Scripts tout court.
- Modifié la method SConfig.loadScripts pour accepter le chargement des scripts globaux de syn aussi.
- AbstractMacro implements maitenant IExecutable  et sa fonction apply() est faite.
- [TODO] [FAIT, dans MacroManager] Ajouter l'instanciation (new ou provider) de Macros dans l'emu pour les ajouter à des IA ou autre.
- [TODO] [FAIT, dans MacroManager] Ajouter une ArrayList des Macros dans GlobalWorld et GameWorld, comme les IA et scripts.



0.0.95.9 [10 Juillet 2013]
- Ajouté la colonne d'iaID dans le tables de monstres dans les db globalworld et gameworld.
- Ajouté la colonne d'xp à la table de monstres du gameworld (j'lavais juste dans celle du global>.>)
- Ajouté le loading de la variable d'XP dans les monstres
- Ajouté le loading de la variable d'IA dans les monstres
- Ajouté la table de scripts dans la bdd syn (c/c de celle qui était dans les gameworlds)
- Créé table macros dans les bdd syn et world
- Ajouté method loadMacros dans SConfig
- Ajouté method download(url, fileName, newPath, newFileName) dans UtilsLib.Misc.Utils
- Modifié la classe Macro & AbstractMacro pour parametrer les AbstractCharacters (caster/target) 
	- seulement au moment de l'exécution au lieu d'au chargement.
- Ajouté le call du SConfig.loadMacros dans l'implémentation de PluginsManager
	- au même endroit ou on met SConfig.loadPlugins (Voir GServer et Services)
- Modifié beaucoup le MacroManager et les classes Macro & AbstractMacro
	- Ajouté params url/filename/name/version/description
	- Ajouté une method pour seulement .create() au lieu de toujours .createAndPreload();
- Supprimé (commenté) la classe FightTimerPoolManager
- Supprimé (commenté) le code de la task FIGHT_TIMER qui est useless mtn qu'on a la DelayQueue
- Modifié la classe DelayingFights : Enlevé le truc de keepAliveTime, enlevé les trucs de this.wait(keepalive) et this.notify, etc
	- C'est la DelayQueue elle-même qui se charge de .await() quand elle est vide (queue.take et queue.poll(time) sont bloquants).
- Corrigé & finalisé les timers de combat (GFight.getDelay), ça roule super bien maintenant :)
- Rename method setEndTurnTime pour mettre setDelay à la place dans GFight
- [TODO] [FAIT] Corriger la reconnection en combat et les packets de tours et le lancement de sorts/cac 
	- et ajouter la protection de la faille de direction orthogonale dans les mouvements en combat. (On est supposé aller juste en diagonale)
- [TODO] [FAIT] Corriger le packet d'emote (bonhommes smileys) en combat : le client vient en chargement infini et n'affiche pas de smiley
- Commencé à debugger les tours de Syn, c'est bizarre, tous les packets sont envoyés seulement lorsque le tour du perso commence.
	- C'est-à-dire tous les GTF/GTR/GTS des mobs ainsi que les GT (GameTurn) sont envoyés seulement quand le tour du perso commence.
	- [TODO] J'en ai aucune idée de pourquoi .___.   ( Vive le debuggeur d'eclipse quand même pour accomplir ça <3 )
	- J'ai fait la comparaision avec les packets de tours de Zen aussi et ce que j'ai ai bon, c'juste le ptit bug bizarre qui faut ...
- [FIXME] J'ai modifié les scripts et là il faut corriger car j'ai créé un bug de : java.lang.NoSuchMethodException: no such method: exe
- [TODO] (Peut-être?) Mettre les scripts et les macros etc dans le globalworld au lieu de Syn ?



0.0.96.1 [11 Juillet 2013]
- Fait beaucoup de tests sur les packets de tours en combats.
	- Quand on envoie GTR, le client renvoie GT
	- Quand on envoie GTF, le client arrête les chronos
	- J'ai essayé plusieurs changements dans l'ordre des GTS/GTR/GTF sans succès jusqu'à maintenant :/
- Le bug que j'ai qu'il me reste, c'est quand on passe. 
	- C'est vraiment bizarre. Quand on passe pas, tout fonctionne extrêmement bien, 0 bug.
	- Mais quand on passe, 
		- on ne voit pas le curseur bouger sur la timeline, 
		- on ne voit pas les images de monstres en haut à gauche
		- le chrono en rond au centre en dessous des pa/pdv/pm ne s'arrête pas, il continue.
	- Alors que pourtant, les packets envoyés sont tous exactement les mêmes.
	- Y'a que les GT qui sont tous reçus à la fin du round au lieu d'à chaque fin de tour, c'qui est très bizarre
		- surtout que quand on ne passe pas, ce problème ne survient pas ...
- Selon moi, ça devrait être ainsi:  >GTS37|30000. blabla on joue. >GTF37. >GTR37. <GT et voilà, on recommence avec le prochain.
	- Mais en fait l'ID dans le GTR on s'en fout pcq le client en prend meme pas compte sauf pour déterminer s'il existe ,
		- mais ça pourrait être n'importe quel ID d'un combattant random qui est dans le combat >.> 
	- L'ID du GTF est important d'être le currentPlayer par exemple pour désactiver le chrono d'inativité.
		- et clearer toute action/timer, curseur de timeline, etc qui est relié au currentPlayer.
	- Et l'ID du GTS ben c'est ce qui détermine qui commence son tour donc x)


0.0.96.2 [12 Juillet 2012]
- Testé en faisant getfight.setDelay(0) quand on passe ton tour, mais aucun effet: 
	- la delayqueue est déjà en train d'attendre sur l'autre temps donné.
- Fait de nouveaux tests avec une nouvelle implémentation de DelayQueue (DelayingQueue2),
	- En fait j'ai c/c leur code dans ma propre classe pour pouvoir y ajouter une method unlock()
	- C'est cette method que j'ai surtout testé pour essayer de stopper le .await que la queue fait quand on take()
	- Mais à date ça marche crissment pas U_u.

0.0.96.3 [15 Juillet 2013]
- Changé le queue.take() par queue.poll(300, TimeUnit.MILLISECONDS) dans DelayingFights
- Tous les tours de combat sont maintenant fonctionnels avec la strategy de DelayingFights.
- Créé package FightSchedulingStrategies pour contenir toutes les stratégies de scheduling que je créé pour les combats
- Créé class statique FightSchedulingStrategies contenant une arraylist des différentes stratégies choissisables
- Créé interface FightSchedulingStrategy à faire implémenter aux différentes stratégies qu'on veut créer.
	- Implémenté dans DelayingFights et FightScheduler
- Créé classe FightScheduler qui est une stratégie utilisant les Executors similairement à ce que j'ai fait dans Zen.
- Renouvellé la FightTimerTask qui est mtn utilisée par le FightScheduler dans ses ScheduledFuture/Executors blabla
- Tous les tours de combat sont maintenant fonctionnels avec la strategy de FightScheduler aussi.
- Ajouté methods schedule, cancel et finish à FightSchedulingStrategy. Tous return boolean et prennent (fight); en args
- Ajouté de la putain de belle javadoc à mes -nouvelles- (seulement) classes de stratégies :)
- Créé method SM.Game.GAF et GAS et les utilise maintenant à la place de GAF/GAS_LAYER 
- Corrigé le packet GAF en rajoutant un "0|" qu'il manquait au milieu.
- On peut maintenant lancer autant de sorts qu'on le veut dans un tour et dans le combat :)
- [TODO] [FAIT] Retirer les PA au combativecharacters lorsqu'ils lancent des sorts/utilisent des armes
	- Soit le faire directement genre stats.decremend(PA, spell.getPA, BOOST)
	- Soit le faire par buffs genre : p.addBuff(GBuff.createNew(GEffect.createNew("str", false, p.getServer().getEffectsManager()), (byte)0, GBuff.BuffApplicationType.OneShot));
	- À faire dans ActionsPlugin.Application.case 300 et case 303 (LANCER_SORT et LANCER_SORT_CAC)
- [TODO] [FAIT] Finir de debug les sorts et les déplacements ainsi que la reconnection en combat.				


0.0.97.4 [16 Juillet 2013]
- Commencé un projet DofusClientReplication pour benchmarker Syn en simulant X connections+packets/s
	- Comme tester le nombre de packets/sec que Syn peut handler, tester le lag, etc.
- Créé la structure principale du DofusClient : Core, Parsers, Senders, Clients(Login/Game)
	- La connection au serveur s'établie assez bien, il reste à remplir les parsers/senders
		- et à utiliser des comptes générés automatiquement pour connecter les multiples clients
- Theo est tlm incompétant i_i.
- Commencé une version de Zen sous Apache Mina. mais quel fou je suis encore .... u.u
- Ajouté nouvelle method notice(ieffectType, caster, target) dans EffectPlugin.Application 
	- pour envoyer les messages de "L'effet truc truc a été appliqué sur target".
	- Ajouté call à notice() à la fin du main Application.apply(); 
- Ajouté nouvelle method de apply() dans le plugin d'effets avec plus de paramètre 
	- qui sera à overrider par chaque EffectApplyer
- Créé nouveau package Applyers dans le plugin d'effets avec deux nouvelles classes:
	- DamagingEffectApplication extends Application 
	- HealingEffectApplication extends Application 
- Ajouté une HashMap<Short effecttypeid, Application> applyers dans la main Application.
- Ajouté nouvelle method private void fillApplyers dans Application qui instancie les applyers
	- fillApplyers est callé dans le EffectsMain.onEnable();
- Ajouté l'instanciation du DamagingEffectApplication et HealingEffectApplication dans fillApplyers
	- + ajouté un if(applyers.get(effecttypeid) != null) -> applyers.get(..).apply(...); notice();
- Le but est d'avoir une classe d'application pour chaque effet pour rendre le tout plus organisé/plus clair.
	- On aurait aussi pu coder leur .apply() individuel dans l'enum SpellEffectType
	- et ensuite caller GEffect.getIEffectType.apply();
	- sauf que l'enum aurait fait des milliers de lignes
- J'pense que j'vais faire cela uniquement pour les plus gros effets qui prennent de la place à coder
	- parce que sinon ça ferait un bien trop gros shitload de classes à créer, 
	- en plus qu'il faudrait qu'elles ailles toutes les noms de leur effet respectif qui est assez compliqué, etc
	- ça ferait de la marde j'pense. 
	- Surtout pour des effets du genre REGIVE_X_ENERGY qui prend 2 lignes de code. 
	- t'imagine une classe avec un nom comme ça ??? dafuq. 
	- Plus simple de laisser ces effets dans le switch principal :)
- Déplacé le switch du premier apply dans le deuxième
	- il ne reste maintenant dans le 1er apply que la vérification + shitzz de targetcombat/castercombat
	- et un call au 2eme apply (soit le main, soit celui d'un applyer) + notice.	 
	
	 
	 
	 
- 17 Juillet 2013 : 
- Travaillé sur Zync, une fusion de Zen et de Syn plus axée sur Zen.
- Commencé un changelog pour Zync dans son dossier de projet respectif

- 18 Juillet 2013
- Travaillé sur Zync. finit de corriger toutes les erreurs de compilation
- Supprimé les anciencs projets du zen workspace: MinaZen, MiscPlugin, IAPlugin, BasicLib...



0.0.97.5 [22 Juillet 2013]
- Travaillé sur les combats:
	- [TODO] Créé method onKilledCharacter [PAS ENCORE CALLÉE PAR l'APPLICATION DE SORT]
	- Créé method areAllPeopleFromATeamDead + callée dans onKilledCharacter et dans endTurn
	- Enlevée l'action de mouvement sur la même cellule dans le PluginParser.GameParser.onGameInformation (à la connection)
	- Changé tous les calls à .endTurn() qui n'était pas dans les threads de scheduling pour des : 
		- NewThreads.FightSchedulingStrategies.FightSchedulingStrategies.getStrategy().finish(f);
	- [FIXME] [FAIT] Actuellement, le client ne comprend pas qu'il est dans un combat, il pense qu'il est encore en freemode :
		- ne peut donc pas peser pour le bouton pour passer de tour, il marche en diagonale, il n'affiche pas auomatiquement les sorts dans la barre de raccourci
	 - Fini de corriger la reconnection en combat : http://pbrd.co/1aEQF52
- [TODO] [FAIT] Gestion des PA/PM/PDV/maxPDV en combat.
- [TODO] Changer les variables pdv+pdvMax dans GStatistiques v
	- pour les mettre dans l'HashMap à la place et ainsi mieux les gérer avec les boosts/dons/équipements
- Ajouté nouveaux constructeurs dans GBuff pour créer les buffs d'utilisation de PA/PM, perte de vie, etc
- Ajouté methods pour get les EffectTypes d'ajout de PA/PM/PDV dans EffectManager
- Changé tous les références numériques à des références directes à l'enum CharacteristicType dans SpellEffectType
	- Exemple au lieu de DAMAGE_X_WATER(96,13,true), on a DAMAGE_X_WATER(96,CHANCE,true)
- Système de buff pour l'utilisation de PA quand on utilise des sorts/cac est fonctionnel.
	- Ajouté l'instanciation d'un GBuff.createNew(xxx) dans EffectPlugin.Application.applySpell/CAC
		- Qu'on ajoute aux buffs du perso et qu'on .apply ensutie et qu'on .decrementTurns ensuite.
	- Ajouté application des effets PLUS_X_PA et MINUS_X_PA dans l'Application d'effets
	- Corrigé le buff.debuff(perso) pour débuffer tous les tours que le buff s'est appliqué
	- Corrigé une concurrentModificationException sur fight.startTurn -> for(caste.getBuffs);
	- Corrigé une nullPointerException quand on .copy() un GEffect (ou GBuff) dont les specialArgs sont null
	- Modifié le SpellEffectType.setOpposite() pour qu'il fasse oppositeEffect.setOppositeEffect(this);
		- Pcq on pouvait pas mettre l'oppositeEffect dans le constructeur de l'enum de chacun 
			- à cause qu'il était défini plus bas dans l'énumération, n'existait pas encore
			- Alors on met l'opposite seulement sur l'effet le plus bas 
			- et ce dernier se charge de setOppositeEffect(this); sur le premier
	- Corrigé l'application des buffs dans fight.endTurn
		- Enlevé le check if(buff.getApplicationMode == Endturn)
		- Enlevé le if(buff.getRemainingTurns == 0) { buff.remove(perso) } else { apply }
- Ajouter des SM.Game.GTM(fight, false) à plusieurs endroits pour bien afficher les PA/PM/PDV actuels des combattants
- [FIXME] [FAIT] L'affichage de l'action PaChanged ne fonctionne pas.
- [FIXME] [FAIT] L'affichage de l'animation de sorts ne fonctionne pas
- [FIXME] [FAIT] Le client bloque après avoir lancé un sort: on peut encore bouger, mais pas sélectionner de sort à lancer
- [TODO] Packet d'affichage des buffs à des combattans qu'on voit en cliquant sur la timeLine
	- ainsi que leurs icônes quand on passe en hover au-dessus d'un sprite


0.0.97.6 [23 Juillet 2013]
- Ajouté un if dans l'apply
	- J'ai ajouté un calcul des PM utilisés et ai ajouté un buff pour les enlever pendant le tour.
		- Si le perso n'a pas assez de PM, on return true en lui envoyant un message pour lui dire
		- Sinon on lui applique un buff pour enlever les PM utilisés.
- Ajouté un if dans applyOnDone de l'action de MOVEMENT dans l'ActionsPlugin 
	- Si le perso est en combat, ça return true avant de checcker pour des items jetés sur le sol
		- ou des groupes de monstres à combattre 
		- et ça envoie le packet GTM_FIGHT pour update l'affichage du nombre de PM de la personne
- Ajouté l'application de plusieurs effets basiques (PLUS & MINUS)  : 
	- PA, PM, RANGE, INTEL, CHANCE, FORCE, AGILITE, SAGESSE, VITALITE
- L'utilisation de PM fonctionne désormais, ne manque plus que l'affichage des notices:
	- "Truc a utilisé X PM"
	- "- X PM" au dessus de sa tête
	- Pareil que pour les PA.
- [TODO] Vérifier les orientations dans les mouvements en combat: ils ne doivent pas pouvoir aller en horizontal/vertical
- Modifier la commande reloadplug pour pouvoir recharger correctement les plugins du syn (défaut) et ceux du game
- Corrigé les packets des actions PA_CHANGED et PDV_CHANGED dans l'ActionsPlugins.ActionsFactory
- Créé enum GameActionEndType dans ActionsPlugin
- Ajouté methods getMovement/SpellEndActionID() dans ActionsManager 
- Ajouté byte gameActionEndTypeID en args dans method SM.Game.GAF pour lui dire le type de GameActionEndType
- [BUG] [FAIT] Le client ne renvoit pas GKK après que j'lui ai envoyé les actions de sorts et de changement de PA..
- Pour l'affichage du -X pa utilisé en haut de la tête du gars, il faut que le client renvoie GKK pour le voir
- Joué à Grand Chase. Like a boss.


0.0.97.7 [24 Juillet 2013]
- Corrigé le bug de GKK qui n'était pas renvoyé. C'était à cause du GTM qu'on envoyait pour réafficher les pa/pm/pdv/pdvmax.
	- Le GTM serts aussi, en fait, à clearer toutes les gameactions dans le client. Donc il n'avait plus rien à me renvoyer :P
- Il va donc falloir trouver une autre solution pour afficher correctement les pa/pm/pdv/pdvmax actuels des joueurs aux autres joueurs.
	- Actuellement, l'action PA_CHANGED a l'air de se charger de l'affichage des PA actuels, c'est cool. Mtn faut envoyer l'action au fightlayer.
- NICE: http://pasteboard.co/1k7pdFAK.png
	- Affichage des - PA/PM/pdv perdus au dessus de la tête fonctionnel
	- Affichage des PA/PM/pdv/PDVMAX actuels sur les bonhommes fonctionnel (genre ça affiche que j'ai 488pdv au lieu de 520 >.>
	- Affichage des animations de sorts fonctionnel
- Du coup :
	- lancement de sort : 100%
	- mouvement : 100% 
	- (y comprit affichage des pa/pm/pdv restant et le -X au dessus de la tête)
- Manque : 
	- installer la fonction onKilledCharacter au bon endroit (la caller)  :D
	- fin de combat (abandonner ou gagner)
	- afficher les épées sur la map pour pouvoir rejoindre
	- spectateur
	- boutons d'aide/bloquer à tout le monde/bloquer au groupe quand on commence un combat, dans la phase de placement
	- emotes [FAIT] : elles ne sont pas affichées et le client devient en chargement infini 
		- mais quand même possible de faire des actions comme lancer un sort, bouger, parler. ...
- [FIXME] Y'a du sérieux lag du côté client lorsqu'on lance un sort avant que son affichage soit fait.		
	- et évidemment le client est complètement gelé pendant ce temps....
- Affichage des épées de combat sur la map fonctionnel : http://pbrd.co/15K6Fjf
	- Aussi, on a pu besoin de faire le SM.Game.remove(character), les packets d'épées s'en chargent.
- Créé enum AlignementSpecializationType
- Créé enum FightSwordFlagType
- Ajouté les methodes de packets: SM.Game.Gc_LAYER, SM.Game.Gt_LAYER, SM.Game.showFightSwordTeams
- Fini l'affichage des épées de combats + liste de membres de équipes. 2 screens  :) : http://pbrd.co/1bjw61H   http://pbrd.co/1bjweOO
- Callé SM.Game.showFightSwordTeams dans FightFactory.createNew juste après le setting des layers et des cellules des monstres etc.
- Enlevé le starter.onRemovedFromMap sur le personnage dans FightFactory.createNew
	- c'est mtn inutile, le packet Gc envoyé par SM.Game.showFightSwordTeams s'en occupe :)
- [TODO] Ajouter la possibilité de rejoindre un combat
	- Ajouter le parsing du packet pour rejoindre un combat (GA 903 1 ; 37  -> actionType 903, fightID 1, teamLeaderStarterCharacterID 37)
	- Continuer la method GFight.join()
	
	
0.0.97.8 [25 Juillet]
- Ajouté le parsing du packet pour rejoindre un combat (action 903 youknnow, c'est fait & ça call fight.join;).
- Créé classe FightTeam extends ArrayList<CombativeCharacter>
- Changé les ArrayList<CombativeCharacter> dans l'arraylist de teams par des FightTeam
- Ajouté les options isClosed, isClosedGroup etc dans FightTeam
- Commencé la fonction join()
	- Les vérifications en fait. Il en manque encore beaucoup comme l'abonnement :/
- Mit le constructeur de GFight private au package pour que seulement la FightFactory puisse en créer.
- [TODO] Changer tous les get(0) sur FightTeam par des getStarter :)
- [TODO] [FAIT] continuer le fight.join()
- [TODO] Ajouter un isPremium (genre isSubsricer/needsSubscription) dans les areas 
	- pour vérifier les trucs d'abonnement :)
	- beaucoup plus optimisé que de mettre le boolean sur chaque map individuellement :)
- On peut maintenant rejoindre les combat : http://pbrd.co/1dYAWO6
- [TODO] [FAIT] Quand on se reconnecte en combat, on repart avec toute notre vie, 
	- ce qu'on avait perdu en combat n'est pas compté dans les GStatistiques
	- Le mieux serait ptete de mettre une colonne COMBAT dans les gstats genre.
	- et que if(fight)-> total+=combat; ? (quand on compte le TOTAL des stats)
- [FIXME] [FAIT] Corriger la timeline avec les 14millions de monstres qui jouent entre chaque personnage http://pbrd.co/1dYAHCF
- [FIXME] [FAIT] Corriger l'affichage au début du combat, dans le tour du premier monstre, 
	- on recoit les packets d'affichage du genre "entre en combat" seulement après son tour.
	- du coup on ne le voit pas faire son tour en fait.
- [BUG] [FAIT] quand qqn rejoint le combat d'un autre, ceux qui étaient déjà dedans ou du moins le leader
	- ne voient plus la timeLine : http://pbrd.co/1dYAHCF



0.0.97.9 [5 Aout 2013]
- Corrigé la method GFight.organizeTimeline();
- Ajouté package colletions avec classes CollectionQuery et Maps2 (thx Shivas de Blackrush)
- Travaillé sur le bug "no such method" de scripting qui fait chier,  pas réussi.... u_u
- Travailllé sur la resconstruction du client dofus (Converti ses classes en vraies classes as2)

0.0.98.0 [6 Aout 2013]
- Corrigé 2 bugs sur la fonction de join() de combat
	- Y'avait des packets de trop envoyés :) Comme le GTL, le .sendActiveFightPackets
	- Y'avait un .organizeTimeline() de trop aussi
- Travailllé sur Synus
	- Ajouté la console d'inject qui est vraiment jolie :3
	- Créé un package commands et des classes CommandsManager, ICommand, HelpCommand implements ICommand, etc
	- [BUG] mais j'ai un problème avec mon CommandsManager, j'arriver pas à caller ses functions


0.0.98.1 [7 Aout 2013]
- Travaillé sur Synus :
	- Réussi à caller les function/classes grâce à ça :
	- Rennomé le package Utils en utils, la majuscule faisait bug à cause d'interfrence avec mx.Utils ou autre
	- Fini l'implémentation du Sender
	- 
- Finalement trouvé le bug qui faisait qu'on voyait pas les monstres jouer avant nous en début de combat
	- y'avait un f.startFight dans la réception du packet onGameReady au lieu de faire :
	NewThreads.FightSchedulingStrategies.FightSchedulingStrategies.getStrategy().finish(f);
- Commencé un ébauche des challenges dans le SystemsPlugin
	- Je pense les faire uniquement sous forme d'observer, mais on verra bien ;p
	- Ajouté arraylist de challenges dans GlobalWorld et GWorld
	- Commencé à créer une table des challenges possibles dans bdd world
- Créé nouveau système d'Events dans nouveau package
	- Le code est prêt à être utiliser
- Changé tous les inState.set(actionlistenertype.on_fight_xxx).notifyobservers(this)
	- pour : inState.notifyobservers(new FightEvent(this, FightEventType.xxx));
- Ajouté des notifications sur l'inState dans l'ActionPlugin 
	- sur les action de mouvement et de lancage de spell en combat:
		- f.getStateMachine().notifyObservers(new FightMovementEvent(f, action));
		- f.getStateMachine().notifyObservers(new FightSpellEvent(f, action));
- Supprimé (commenté) tous les minimumIDinWorldItemTemplateTable dans CServers
	- pour ne laisser qu'un seul universel setté à 15001 : minimumWorldObjectID
- [TODO] Supprimer la variable inState dans GFight et la faire extend Observable 
	à la place du machine state ?
	on aurait alors fight.addObserver(new xx) et fight.notifyObservers();  :)
- Ajouté le ChallengesObserver aux combats dans FightFactory.createPVM
- Bougé le ChallengesObserver dans l'emu au lieu du SystemPlugin
- Créé classe Applications dans notre ancien package Challenges dans le SystemsPlugin
	- On pourrait s'en servir pour les challlenge.check(event) ;o
	- de la même manière que l'application des effets et des gameactions
-

0.0.98.2 [8 Aout 2013]
- Continué les challenges
- Supprimer le package FightChallenges et la classe Application quyavait dans SystemsPlugin
- Ajouté une variable verifierScript dans GChallenge 
- [TODO] [FAIT] ajouter une colonne scriptID dans table de challenges pour charger les script vérificateur dans les GChallenges
- [TODO] Faire un ChallengeTemplate vs GChallenge "instance" ?
- Ajouté methods onFail et onWin dans GChallenge
- Complété le ChallengesObserver
- Ajouté les methods de packet dans le SM.Game -> Gd et GdUpdate
- Remplit la base de la table de challenges dans le global. Manque de remplir les scripts et les eventType
- Continué ma propre classe d'observable dans la UtilsLib
	- Ajouté methods notifyObserver(Class c), getObserver(Class c), etc
- Ajouté un ID aux ExecutableScripts pour que quand on se sert de l'ID d'un script en chargement
	- on sache si on va chercher le script dans les scripts par défaut de syn ou dans le gameserv
- Ajouté la colonne d'ID dans les tables de scripts
- Ajouté les varieables bonusXpPerAlly et bonusDropPerAlly dans GChallenge
	- avec des methods pour connaître le total de bonus d'équipe (personnagescount * bonusPerAlly)
- Enlevé la variable fight dans ChallengesObserver qui était inutile 
	- vu qu'on peut aller la chercher via le FightEvent :)
- Ajouté le parsing du ON_FIGHT_END dans ChallengesObserver pour donner les bonus en xp/drop au GameResult :)
- Ajouté l'envoie du packet de challenges à l'event ON_FIGHT_RECONNECTED dans ChallengesObserver :)
- [TODO] Faire un script pour la génération intelligente de Challenges en début de combat ?
	- Genre y'a des challenges qui sont impossibles à réaliser ensemble comme Économe et Barbare
	- Donc faudrait un petit truc pour générer quelque chose de cohérent. :P
- 


0.0.98.3 [9 Aout 2013]
- Trouvé mes bugs de scriptings, ça marche bien mtn
- [TODO] Recoder le script de pub
- Ajouté method reEval() dans ExecutableScript qui permet de réévaluer le fichier d'un script après qu'on l'ai modifié
	- De base, la Task (NewtThreads.Task) d'exécution de script ne réévalue jamais le script (sauf en mode debug)
	- à chaque exécution pour économiser en ram/cpu. 
	- Donc à moins d'être en mode debug ou le script est reevel à chaque execution, 
		- il faut faire la commande REEVALSCRIPT [default.ALL ou game.ALL] 
		- pour réévaluer des scripts après les avoir modifier. Sinon les modifs ne seront pas prises en compte.
	- [TODO] Faudrait un autre champs config à la place du mode debug pour activer la réévalution automatique des scripts.
- Créé commande REEVALSCRIPT dans le ConsolePlugin

0.0.98.4 [10 Aout 2013]
- Ajouté champs config permanentDamagePercent pour les dommages permanents perdus à chaque coup reçus 
	- (10% des dommages reçus par défaut)
- Grosse refonte sur la gestion des stats de pdv et pdvmax.
	- Delete variables pdv et pdvMax dans GStats
	- Utilisation de la CharacteristicType  LIFE_POINTS(0) pour stocker les pdvs courrants
	- Nouvelle method getPdvMax(character) qui utilise la classe du character pour return le bon pdvMax
		- en fonction des startPdvMax, gainedStatsPerLevel ..
	- Utilisation de la CharacteristicType  DOM_PERMANENT(0) pour aider au calcul des pdvMax actuels
		- DOM_PERMANENT étant les pdvMax qu'on a perdus en recevant des coups en combat
		- Par défaut, on perd 10% des dommages reçus à chaque coup
	- Modifié le chargement des stats des monstres. Stock maintenant la colonne "pdv" dans VITALITE&LIFE_POINTS 
	- On ne stock plus les pdvMax nul part, ils sont calculés constamment dans la method getPdvMax
	- Les pdv LIFE_POINTS sont stockés uniquement dans BASE. On a pas besoin des autres colonnes pour ça.
- Convertis toutes les classes qui implémentaient java.utils.Observer en Observer de ma propre lib
	- pareil pour l'ObservableState des combats.
- Créé une animation flash pour faire une pluie de météorites pour le mode DarkWorld :)
	- http://www.synworld.net/videos/meteorShower/Untitled.html
- Ajouté des putCharact(0, PA, FIGHT); putCharact(0, PM, FIGHT) à la fin des tours en combat pour reset ça :)
- Pdv insoignables fonctionnent parfaitement avec les DOM_PERMANENT :D
- Toutes les stats sont bien stockées même après avoir déco/reco :)
- Si on se déconnecte durant que notre tour est en cour, 
	- celui-ci n'est pas passé pour pouvoir reco dedans et de le continuer
- Si on se déconnecte en combat et qu'on est en équipe avec d'autres personnages, 
	- nos tours sont passés pour ne pas les faire attendre.
	- Mais si on est le seul personnage dans notre équipe, 
		- les tours ne sont plus passés pour laisser le plus de temps possible au gars pour se reconnecter :)
- [TODO] Corriger l'initialisation de buffs quand on lance des sorts comme Vent empoisonné/Tremblement
	- Actuellement ça bug pas mal.
	- Exemple: Les dommages sont appliqués au moment ou on lance le sort (ce qui est mauvais) 
		- mais jamais durant les tours suivants (ce qui est encore pire)
	- Pour les buffs de stats comme Vent empoisonné qui enlève de l'intel, 
		- l'effet est bien appliqué durant tous les tours, mais il n'est pas enlevé à la fin du buff.
	- Faut rajouter les packets pour les buffs aussi :) 
		-  (+ ne pas oublier de les renvoyer aussi quand on se reco en combat)

0.0.98.5 [11 Aout 2013]
- Ajouté le parsing du paquet GQ (Abandon en combat)
- Ajout du code pour bien quitter le combat après 20 tours de déconnection dans le FightDeconnectedObserver
- Ajouté les actions KILL_UNIT et REDUCE_DAMAGE dans l'enum, la factory et les call dans les effets de dommages
- Corrigé l'envoie de plusieurs packets de combat:
	- Tous ceux qui se servaient de la timeLine pour envoyer des packets à tout le combat se sont fait ajouté ca:
		- && combativecharacter.getLayer() == fight.getLayer();
- Ajouté l'utilisation du FightState FINISHED pour que le FightScheduler call .endFight() 
	- au lieu du traditionnel endTurn() lorsque le combat doit finir (ex onCharacterKilled) 
- Ajouté byte oldLayer dans GFight + les get/set
- Créé class GameResult avec inner class Gains 
	- (y'aura un objet de Gains par combattant pour stocker ce qu'il gagne/perd) 
- Modifié le fight.onKilledCharacter + ajouté des calls dans DamageEffetApplication et FightDeconnectedObserver
- On ne retire plus les personnages des comabts lorsqu'ils déco/abandonnent
	- À la place, j'ai modifié le CombativeCharacter.getFight pour qu'il return null si != layer
- Plein de choses ;o 
	- comme le système de layers des combats (peut avoir des combats sur des layers différents)
		- Quand on finit un combat on reviens à l'ancien layer qu'on avait et non au baseLayer
- Bref, on peut maintenant abandonner des combats
	- finir des combats en tuant tout le monde d'une équipe
	- et ce en solo ou en multi joueur :)
- [TODO] Rajouter les colonnes d'XP des obvijevans et tourmenteurs (ce nest pas pareil que les bandits)
- Rajouté une method "best" dans CollectionsQuery dans UtilsLib
- [TODO] Remplacer les tableaux d'XP par des formules math. à trouver grâce à excel ?
- Ajouté method calculateXpGain dans les formules
- [TODO] Continuer le GameResult et la formule de calcul de l'xp gagnée



0.0.98.6 [6 Octobre 2013]
- Correction de la method calculateTeamXpCoefficient dans PluginFormuling.Maths.Formulas
- Ajouté var CombativeCharacter winner dans classe Gain (innerclass de GameResult)

0.0.98.7 [14 Octobre 2013]
- Bougé enum FightTeam de GFight dans le package Enums à la place et rename en FightTeamEnum
- Ajouté methods first() et getStarter() dans FighTeam qui font la même chose
	- et commencé à remplacé quelques calls à team.get(0) par first()
- Corrigé un bug de typo dans l'ObjectParsing, j'avais mit 3 au lieu de 2 dans un index d'array :S
- Ajouté class GameResultPvm
- Créé un GameResultProvider et l'ai ajouté au ProvidersManager de base
- Rendu les constructeurs de chaque GameResult 
	- en package-restricted pour obliger à utiliser le provider :)
- Enlevé l'objet CombativeCharacter winner de Gain 
	- et remplacé l'ArrayList<Gain> par HashMap<CombativeCharacter, Gain>
- Enlevé le provider et remit le construct de GameResult public finalement
	- + enlevé les implémentations GameResultPvm etc, tout en une classe ça fonctionne très bien
- Créé enum FightTeamResultType dans FightTeam
- Packet de GameResult fini
- Manque juste qq autres packets pour que le endFight soit fini
	- pcq là le client affiche mal le GE à cause de ça
	- et il continue d'Envoyer le qping alors qu'il devrait pas.
- Complété la method .distribute() du GameResult et l'ai calé dans le GFight.endFight :)
- Ajouté method addXP dans GPerso fait gère en même temps tout le levelup
	- (gainedStatsPerLevel, vie à 100%, sorts apprits, packets...)
- 
 

0.0.98.8 [22 Octobre 2013]
- Ajouté method getMount() dans personnage
- Ajouté method isMountSheetEffect dans l'effectmanager/application/bla
- Concernant les dragodindes : 
	- Sur l'item lui-même, il faut afficher : 
		- Le nom ("Nom : blablacookie")
		- Le nom du possesseur ("Appartient à : blablamaster")
		- La phrase/bouton "Consulter la fiche de la monture" (c'est dans cet effet qu'on met l'ID de la monture)
		- Le temps de validité du certificat ("Validité : 39j 16h 42m")
 	- En cliquant sur "consulter la fiche de la monture" (donc des vars dans GMount), on a accès à : 
 		- Tous onglets :
 			- type de dd (pourpre, émeraude, doré, etc), son niveau, 
 			- nom, sexe, si elle est montable, si elle est sauvage
 			- bouton "voir son arbre généalogique"
 		- Onglet Général :
 			- son énergie, expérience, fatigue, nb de reproductions, 
 		- Onglet Statistiques :
 			- amour, maturité, endurance, happiness(aggressivité vs sérénité)
 		- Onglet Effets : 
 			- Bah ce que donne la dd : vitalité, force, chance, sagesse, pm, po, etc
 		- Onglets Capacités
 			- si elle est Reproductrice, Caméléonne, Sage, etc

0.0.98.3 [27 Octobre 2013]
- Amélioré le startup de 300ms en changeant les string.split par StringUtils.split2
	- dans le chargement des sorts
- Changé l'ArrayList<IItemTemplate> dans GlobalWorld par HashMap<Short, IItemTemplate>
- Optimisé le chargement des sorts au startup en créant un seul query/resultset
	- pour charger tous les sorts dont on a besoin à ce moment là
	- (Utilisation de "WHERE ID IN (id1,id2,id3...); à la place d'en charger un à la fois)
- Donc le startup de l'emu est passé de ~1900ms à ~1350ms
[TODO] constructeur de GEffects : 
/**
	 * Créé un effet du style utilisé sur les sorts. 
	 * <br>(pas exactement pareil que pour les items du à la mise en forme de la bdd d'ancestra. 
	 *		C'pas trop grave, ca me dérange pas. 
	 *		TODO Peut-être optimiser plus tard la bdd et/pour mettre un seul GEffect.createNew)
	 * @param stats - Ex: 96;9;13;-1;0;0;1d5+8 -> 
	 * 				      effectID ; min ; max ; morph ; durée ; probabilité ; dice
	 */
- Faudrait utiliser la classes EffectsShare à la place! 



0.0.98.4 [2-3 Novembre 2013]
- Changé le PluginInjecting par PluginProviders
- Les providers du ProvidersManager sont maintenant instanciés via le ProvidersPlugin
	- au lieu de directement dans ProvidersManager.
	- Comme ça on les instancie une seule fois dans le defaultPluginsManager
	- au lieu de dans chaque manager de gameserveur
- Créé package Providers
- Créé tout plein de classes de IProvider dans le package de Providers
	- et bougés ceux qui étaient écrits en subclass (Ex: GItemProvider qui était ds GItem)
- Créé le package de GameClientStrategies + les classes pour Dofus/WakfuStrategy, 
	- une enum pour tous les contenir, et une abstract pour qu'ils extends une GameClientStrategy commune
- http://pbrd.co/17ANazo  :D
- Commencé à implanter le système de GameClientStrategies plus en profondeur :
	- Delete le defaultPluginManager+scripts+sqlGlobalService qui étaient dans Services
	- Ajouté les services Dofus/WakfuClientStrategy aux Services
		- Les GameClientStrategy contiennent mtn chacun un : globalWorld,sqlGlobalService,scripts,defaultPluginManager 
	- Bougé les tables plugins/scripts/macros dans syn_global au lieu de syn
	- Créé une deuxième BDD globale pour wakfu :)
	- 
	
	
	
	
- TODO : En fait, pour les sorts, il peut y avoir un seul niveau desfois.
	- Donc le minimum de 4-5 ou 6 comme on le pensait avant est faux. De toutes façons ça sera mieux comme ça :)
	- Faudrait plutôt pouvoir mettre une infinité de niveaux configurables aux sorts (vu que wakfu = 100)
	- Ça serait plus cool à ajouer avec aussi en plus :D
	- Donc j'pense que du xml ou qqc comme ça serait approprié
	- Sinon faudrait une ligne par niveau de sort et ça prendrait beaucoup de place en bdd, 
		= ça serait pas trop clair à naviguer.
	- Faudrait aussi faire la même chose avec les monstres, un nombre infini de grades. (moins important)
	
	
	
- GROS PROBLÈME : 
	- Quand on SQL.xxx.load(world)
		- Disons GameWorld.getMap(id = 7411) donc ça le transfert au global
			- là ça charge dans SQL.map.load(7411, global)
			- là ça prend le globalSqlService de la strategy, ce qui est correct
			- sauf que ça prend le defaultPluginManager de la strategy à la place de prendre celui du serveur dans lequel on est !
			- 
		- Et metons
	
	
	
	
	
	

// Dans le futur, si on veut adapter Syn à Wakfu/Dofus 2.0,
// faudrait le faire en créant une classe GameClientStrategies
// de la même manière que les FightSchedulingStrategies.
// Chaque LoginServer aurait sa stratégie choisie en config (choix du client à servir)
// Et ensuite, en fonction de la stratégie choisie, cela chengerais 
// la stratégie de socketserver (delimiters/etc..)
// ainsi que le ParsingPlugin
// ainsi que (exemple sur Wakfu) : 
	il y aurait genre un SpellTree avec l'XP accumulée sur chaque sort, etc
	Donc les GSpell ne seront plus les mêmes; comme plusieurs autres choses qui changeront.
// On pourrait donc utiliser une fois de plus les Providers pour se charger 
// du choix d'implémentation de chacun de ces objets en fonction de la GameClientStrategy
// pour les créer de la bonne façons. 
// Cela veut aussi dire qu'il faut ajouter une couche d'abstraction par-dessus chaque objet :
// exemple : AbstractSpell > Dofus1Spell / Dofus2Spell / WakfuSpell.
// Concernant le provider, exemple de code :
//	public AbstractSpell SpellProvider.createNew(GameClientStrategy)
//		if(GameClientStrategy == Dofus1) return createNewDofus1Spell(); 
//		if(GameClientStrategy == Dofus2) return createNewDofus2Spell();
//		if(GameClientStrategy == Wakfu) return createNewWakfuSpell();
// Cela veut aussi dire qu'il y aurait plusieurs GlobalWorlds : un par clientstrategy
// donc soit faire : GlobalWorld.public static GlobalWorld get(GameClientStrategy)
// soit faire GameClientStrategy.getGlobalWorld()
//




- En gros le but est de transformer toutes les constantes (Comme dans le package Constants)
	- ... en variables rechargeables via bdd, plugin, script, xml etc.
	- C'est de rendre l'émulateur morhpable au complet au lieu de seulement quelques effets, quelques actions et tout.
		- Il faut sortir de l'idée "dofus" et s'enligner sur qqc de plus global 
			- (même si bon la structure packets et compagnie reste celle de dofus),
			- ...mais faut le plus possible rendre toute ça abstrait, modifiable on-the-go...
			- Par exemple les formules de calculs pour les dommages, prospection, soin, pods, etc en dynamique,
			- ... les parametres des classes (fait avec Classe.java), les effets scriptés, 
			- ... les constantes comme le maximum de 23 sorts équipables en même temps (si le créa modifie son client)
			- ... les commandes chat/console, 
			
	
	
Alors les todo: 
				- Remplir la table classes_config de défaut avec toutes les classes officielles [manque les rates de capital/points)
				- Faire les formules de calculs de paliers de stats
				- Finir les Classe et Command  (+ booster les possibilités des paramètres pour les commandes, check dans l'apply, c'pourri)
 				- perso.spellsLists(+bouger+booster spell+packets+saves), [FAIT, manque juste spellForget]
 				- Gifts (GiftList, GiftAssign, Save, Delete)
				- map.actionsListeners,  
				- Régénération auto vie persos,
				- effects(coder les application),	
 				- system de cache distribué entre ++ JVMs pour pouvoir séparer le login et les games 
 					- sans avoir a charger les données de l'officiel sur chaque game
 					- Ainsi les plugins doivent être chargés par les game et non le login (y peut yavoir des modifications dans chaque plugin de chaque serveur comme les commandes dispos en chat)
 					- 
 				- gbuff (rendu à mettre en application/tester)
 				- gclient.ban();
 				- Note: Les Syn.w/.d/.wD, Ansi, System.out.println et cie prennent bcp de temps CPU lorsque c'est dans une méthod souvent répétée (Comme le SM.send)
 				- Intrareboot
 				- Profile sur le GInventory.(un)equip, GStats.boostEquipmentStats
 				- Faire ma propre lib de systeme de plugins pour plus de performances qu'avec celle de mathias
 				- Faire le saveAll/cleanAll/rebuildAll dans GWorld et le Login/GameServer.off()
 				- Refaire les Queue (surtout le truc de numberOf(non)PremiumClients dans LServer
				- J'ai fait du profiling principalement sur GInventory.(un)equip, GStats.boostEquipmentStats, Account.As, 
					- Faut booster ça :P, c'est intéréssant (genre moyenne 25ms par boostEquipmentStats, moy.10ms par As, 2X pour .equip) 
					- (J'ai prit des screenshot) Les method.invoke aussi sont trop lent (comme dans gghandler et CodeInput.callMethod)
				- Faire le systeme de relations (Amis/ennemis/ignorés, principalement les packets, j'pense que le reste est déjà là)
	

- TODO : Faire plusieurs instances de maps si elles deviennt trop pleines de joueurs (genre +80 joueurs sur une map)
@  mathias52	:	(18 janvier 2013 - 06:25 )pour les maps, tu limites le nbr de joueur par map ? (MapTemplate / MapInstance)
@  Crystal	:	(18 janvier 2013 - 06:26 )non pas encore, j'ai déjà fait ça sur Zen par contre mais seulement pour map shop/pvp x)
@  mathias52	:	(18 janvier 2013 - 06:26 )MapTemplate : MapInstance.getInstance(); <- Instance ou il y a moins de x joueurs, s'il n'y a pas d'instance dispo, on en créé une nouvelle
  Ca pourrait être style un MapsManager avec une HashMap<mapID, ArrayList<Map>> maps = null;
  	avec une instance de map par entrée d'Arraylist
  	Donc pour le MapsManager.getMapInstance(mapID){
  		for(Map m : maps.get(mapID))
  		{
  			if(m.getSprites.size() < GConfig.maxSpritesOnMap){
  				return m;  //Si on trouve une instance de la map avec un nombre correct de sprites
  			} 
  		}
  		//Si on trouve pas de bonne instance de map: créé une nouvelle et ajoute à l'arrayList
  		Map m = new Map(mapID, blabla);
  		maps.get(mapID).add(m); 
		return m;
	}	
		
		
		
		CORRECTION PACKET AXK / AYK
On envoi au joueur le packet AYK ou AXK, selon les cas :
Si le joueur peut se connecter :
• Si l’hôte est sous le format d’une adresse IP, il sera possible d’encrypter l’IP et le port (encryptedHost), dans ce cas on utilise le packet AXK, formé comme suivant : AXK + encryptedHost + TicketKey
Exemple :
• Si HostAdress n’est pas sous forme d’IP (nom de domaine par exemple), il est nécessaire d’utiliser le packet AYK, formé comme suivant : AYK + HostAdress + ‘:’ + port + ‘;’ + TicketKey AXK7?0@0@01bw8Rj8I-fxeiV

		
		
		
	

PLAN D'ACTION: Bon là faut compléter les items et les statistiques avant même de pouvoir bouger sur la map.
	- C-a-d: 
		- Créer la table ItemTemplate dans le Login ET dans les Worlds et la remplir! [FAIT]
			-> Faut : ID, stats, conditions, parametres. [FAIT]
		- Créer un item (commande/action), [FAIT]
		- Afficher l'item dans l'inventaire [FAIT]
		- Équiper un item [FAIT]
		- Déséquiper un item [FAIT]
		- Updater les stats quand on équipe/déséquipe un item [FAIT]
		- Détruire un item [FAIT]
		- Placer un item dans la barre rapide en bas à droite [FAIT]
		- Utiliser un item (Bonbons, pains, potions, ) [FAIT, manque juste qq item spéciaux like bonbons]
		- Jeter un item par terre [FAIT]
		- Interdire de jeter un item sur une case occupée ou nulle (ex il y a déjà un item)  [FAIT]
		- Prendre un objet qui était par terre [FAIT]
		- Modifier les pods en boostant charac ou par un objet. [FAIT]
		- Gérer les pods style: impossible de bouger si pods>podsMax. 
		- Équiper un item par dessus un autre (Enlever l'ancien d'abord et ensuite mettre le nouveau) [FAIT]
		- Avoir des jets aléatoires sur les stats des items [FAIT]
		- Gérer les conditions d'équipement (Align, Grade, Stats, pods, classe, etc) [FAIT]
		- Enlever le bouclier si on équipe une arme à deux mains [FAIT]
		- Bloquer l'équipement de bouclier avec une arme à deux mains [FAIT]
		- Revérifier les conditions de chaque item équipé quand on en déséquipe un. [FAIT]
		- Interdire l'équipement de deux items identiques de la même panoplie (Anneaux) [FAIT]
		- Gérer les items d'incarnations (Morphs, sorts, xp, lvl, etc)
		- Gérer les familiers/dragodindes
		
		- Augmenter des charactéritiques de base (Vitalite, Sagesse, Intel, Force, Agi, Chance) [FAIT]
			- Ce qui augmente aussi l'esquive pa/pm, les pods, les soins, les cc, la prospec    [TOFINISH]
		- Calculer l'initiative en fonction de toutes les autres characs gagnées par les items [TOFIX]
		- Caculer les taux de coups critiques (agi + cc)
		- Calculer la prospection (chance + prospec)  [FAIT]
		- Calculer les pods (force + pods)  [TOFIX]
		- Calculer les taux d'esquives PA/PM (sagesse + %d'esquives) [FAIT]
		- http://forums.jeuxonline.info/showthread.php?t=801243  (Pour les formules de calculs)
		- 

	PROCHAINES ÉTAPES:
		- Enlever les if(template == null)return 0 dans GItem.java [FAIT]
		- Aller voir le chargement des itemTemplate dans SQL.Items.loadTemplate [FAIT]
		- Ajouter une vérification pour ne pas créer de new GItem() si le template est null [FAIT]
		- Vérifier que le packet pour afficher les accessoires est bon et si y'a dautres packets en relation avec les items aussi [FAIT]
		- Optimiser les colonnes SQL: leurs types et leur length pour de meilleurs performances CPU ET RAM
		- Remettre mapID(ds ICharacter) et itemTemplateID en short et interdire aux créateurs d'utiliser des ID < 15000 et > 32000



PLAN D'ACTION POUR ENSUITE: 
	- Terminer les gifts: 
		- Commande pour ajouter un gift à un account, 
	 	- Ajouter les items aux inventaires des persos quand on prend les gifts en se connectant.
	 	- 
	- Faire les banques (En passant, il pourrait y'avoir des bugs d'indexage avec la variable curPerso si metons euh la banque est pas au meme index que le perso, metons que cest mélangé...on sait jamais, faut controler ça)
	- Faire les poubelles 
		(useless, mais c'est juste des banques sans owner, banque que tout le monde peut accéder. 
		On pourrait faire une interface Storage implémentée 
			par GInventory, Bank, TrashBin, DragoInventory, Coffre(Chest/Safe/Trunk)...)
	- Updater le premiumTime chaque dans SQL.Accounts.save et chaque fois qu'on arrive aux écrans PersoList et ServerList (Packet SM.Accounts.ALK et AxK) [FAIT]
	- Échanges !	
	- 



IDÉES:
[15:48:25] Wendy (Graph): tu peux mettre comme dofus 2.9?
		 par exemple : si on tape avec une sort feu sa met couleur rouge
		 



TODO:
- Quand on entre en combat et que le perso est assis/couché, on doit le mettre debout et l'enlevé du LifeRegenerator
- Lister les emotes que le personnage a apprit pour controler s'il a le droit de les faire. (Implenter du même coup l'emote Champion qui fait applaudir tout le monde sur la map qui est pas en cbt)
- Ajouter des ((GPersonnnage)z).getFight == null dans les itérations de character sur les map quand on envoie (ex) un packet de message général ou d'emote ou de smiley etc
- TODO : les nouvelles commandes consoles et chat (Avec GM, VIP, etc configurable en fou)
- Fixme: un peu de termination à ajouter/corriger dans LBank, GItem, LAccount.
- TODO : Faire les banques.
- TODO : Mettre un champs config pour niveau minimum pour demander le panel avec la question/réponse secrete pour delete un perso
- TODO : ajouter le vrai logging dans des files
- Monitorer le nombre d'objets GServ/GConf/GPersos/etc sur le profiler pour quand on en supprime ou off un pour voir si tout se supprime bien de la RAM.
- Continuer la finalization
- Faire la table des Maps(Cartes)
- Faire la table de ItemTemplate
- Trouver le meilleur compromit pour le stock dans les L/GWorlds (HashMaps/ArrayList/AtomicblablaArray/..)
- Continuer le onSelected
- Migration de serveur
- Pathfinding avec A*
- Chercher les formules de pathfinding de l'officiel dans le client (Exemple quand on bouge la souris en combat et qu'on voit le chemin qui s'offre à nous pour bouger, bah avoir la formule pour savoir comment cr er ce chemin)


BUGS:
- 






